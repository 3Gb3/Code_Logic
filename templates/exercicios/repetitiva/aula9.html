{% extends "base_aula.html" %}

{% block title %}Aula 9 - Algoritmos com Loops | CodeLogic{% endblock %}

{% block lesson_title %}Aula 9 ‚Äì Algoritmos com Loops{% endblock %}

{% block lesson_content %}
    <section>
        <h2>üéØ Objetivo</h2>
        <ul>
            <li>Implementar algoritmos cl√°ssicos usando loops</li>
            <li>Entender busca e ordena√ß√£o</li>
            <li>Resolver problemas algor√≠tmicos comuns</li>
        </ul>
    </section>

    <section>
        <h2>üîç Algoritmos de Busca</h2>
        
        <h3>1. Busca Linear</h3>
        <p>Percorre a lista elemento por elemento at√© encontrar o valor procurado.</p>
        <pre><code>def busca_linear(lista, valor):
    """Busca um valor na lista e retorna sua posi√ß√£o"""
    for i in range(len(lista)):
        if lista[i] == valor:
            return i  # Retorna a posi√ß√£o
    return -1  # N√£o encontrado

# Teste
numeros = [64, 34, 25, 12, 22, 11, 90]
valor_procurado = 22

posicao = busca_linear(numeros, valor_procurado)
if posicao != -1:
    print(f"‚úÖ Valor {valor_procurado} encontrado na posi√ß√£o {posicao}")
else:
    print(f"‚ùå Valor {valor_procurado} n√£o encontrado")</code></pre>
        
        <h3>2. Busca com M√∫ltiplas Ocorr√™ncias</h3>
        <pre><code>def buscar_todas_posicoes(lista, valor):
    """Encontra todas as posi√ß√µes onde o valor aparece"""
    posicoes = []
    
    for i in range(len(lista)):
        if lista[i] == valor:
            posicoes.append(i)
    
    return posicoes

# Teste
numeros = [1, 3, 5, 3, 7, 3, 9]
valor = 3

posicoes = buscar_todas_posicoes(numeros, valor)
print(f"Valor {valor} encontrado nas posi√ß√µes: {posicoes}")
# Sa√≠da: [1, 3, 5]</code></pre>
    </section>

    <section>
        <h2>üìä Algoritmos de Ordena√ß√£o</h2>
        
        <h3>1. Bubble Sort</h3>
        <p>Compara elementos adjacentes e os troca se estiverem fora de ordem.</p>
        <pre><code>def bubble_sort(lista):
    """Ordena a lista usando bubble sort"""
    n = len(lista)
    
    # N√∫mero de passadas
    for i in range(n):
        trocou = False
        
        # √öltima posi√ß√£o j√° est√° ordenada
        for j in range(0, n - i - 1):
            # Trocar se o elemento atual > pr√≥ximo
            if lista[j] > lista[j + 1]:
                lista[j], lista[j + 1] = lista[j + 1], lista[j]
                trocou = True
        
        # Se n√£o houve troca, a lista j√° est√° ordenada
        if not trocou:
            break
    
    return lista

# Teste
numeros = [64, 34, 25, 12, 22, 11, 90]
print(f"Original: {numeros}")

ordenados = bubble_sort(numeros.copy())
print(f"Ordenado: {ordenados}")</code></pre>
        
        <h3>2. Selection Sort</h3>
        <p>Encontra o menor elemento e o coloca na primeira posi√ß√£o, depois repete para o restante.</p>
        <pre><code>def selection_sort(lista):
    """Ordena a lista usando selection sort"""
    n = len(lista)
    
    for i in range(n):
        # Assumir que o primeiro elemento √© o menor
        min_idx = i
        
        # Encontrar o menor elemento no restante
        for j in range(i + 1, n):
            if lista[j] < lista[min_idx]:
                min_idx = j
        
        # Trocar o menor encontrado com o primeiro elemento
        lista[i], lista[min_idx] = lista[min_idx], lista[i]
    
    return lista

# Teste
numeros = [64, 34, 25, 12, 22, 11, 90]
print(f"Original: {numeros}")

ordenados = selection_sort(numeros.copy())
print(f"Ordenado: {ordenados}")</code></pre>
    </section>

    <section>
        <h2>üî¢ Algoritmos Matem√°ticos</h2>
        
        <h3>1. N√∫meros Primos</h3>
        <pre><code>def eh_primo(n):
    """Verifica se um n√∫mero √© primo"""
    if n < 2:
        return False
    
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    
    return True

def listar_primos(limite):
    """Lista todos os primos at√© um limite"""
    primos = []
    
    for num in range(2, limite + 1):
        if eh_primo(num):
            primos.append(num)
    
    return primos

# Teste
limite = 50
primos = listar_primos(limite)
print(f"N√∫meros primos at√© {limite}:")
print(primos)</code></pre>
        
        <h3>2. Sequ√™ncia de Fibonacci</h3>
        <pre><code>def fibonacci(n):
    """Gera os primeiros n n√∫meros da sequ√™ncia de Fibonacci"""
    if n <= 0:
        return []
    elif n == 1:
        return [0]
    elif n == 2:
        return [0, 1]
    
    fib = [0, 1]
    
    for i in range(2, n):
        proximo = fib[i-1] + fib[i-2]
        fib.append(proximo)
    
    return fib

# Teste
n = 15
fib_sequence = fibonacci(n)
print(f"Primeiros {n} n√∫meros de Fibonacci:")
print(fib_sequence)</code></pre>
        
        <h3>3. M√°ximo Divisor Comum (MDC)</h3>
        <pre><code>def mdc(a, b):
    """Calcula o MDC usando algoritmo de Euclides"""
    while b != 0:
        resto = a % b
        a = b
        b = resto
    
    return a

def mdc_lista(numeros):
    """Calcula o MDC de uma lista de n√∫meros"""
    resultado = numeros[0]
    
    for i in range(1, len(numeros)):
        resultado = mdc(resultado, numeros[i])
        
        # Se MDC = 1, pode parar
        if resultado == 1:
            break
    
    return resultado

# Teste
nums = [48, 18, 24]
print(f"MDC de {nums}: {mdc_lista(nums)}")</code></pre>
    </section>

    <section>
        <h2>üéÆ Exerc√≠cio Pr√°tico</h2>
        <div class="exercise-box">
            <h3>Kit de Algoritmos</h3>
            <p>Implemente estes algoritmos usando loops:</p>
            <ul>
                <li>Encontrar o maior e menor elemento</li>
                <li>Calcular m√©dia, mediana e moda</li>
                <li>Verificar se uma lista est√° ordenada</li>
                <li>Remover duplicatas mantendo ordem</li>
            </ul>
            
            <textarea id="code-input" placeholder="# Kit de Algoritmos
def encontrar_maior_menor(lista):
    '''Encontra maior e menor elemento'''
    if not lista:
        return None, None
    
    maior = menor = lista[0]
    
    for num in lista[1:]:
        if num > maior:
            maior = num
        if num < menor:
            menor = num
    
    return maior, menor

def calcular_estatisticas(lista):
    '''Calcula m√©dia, mediana e moda'''
    if not lista:
        return None, None, None
    
    # M√©dia
    soma = sum(lista)
    media = soma / len(lista)
    
    # Mediana
    lista_ordenada = sorted(lista)
    n = len(lista_ordenada)
    if n % 2 == 0:
        mediana = (lista_ordenada[n//2 - 1] + lista_ordenada[n//2]) / 2
    else:
        mediana = lista_ordenada[n//2]
    
    # Moda (valor mais frequente)
    frequencias = {}
    for num in lista:
        frequencias[num] = frequencias.get(num, 0) + 1
    
    moda = max(frequencias, key=frequencias.get)
    
    return media, mediana, moda

# Continue implementando os outros algoritmos...

# Teste com dados
dados = [5, 2, 8, 2, 9, 1, 5, 5, 7]
print(f'Dados: {dados}')

maior, menor = encontrar_maior_menor(dados)
print(f'Maior: {maior}, Menor: {menor}')

media, mediana, moda = calcular_estatisticas(dados)
print(f'M√©dia: {media:.2f}, Mediana: {mediana}, Moda: {moda}')"></textarea>
            
            <button onclick="runCode()" class="btn-run">‚ñ∂Ô∏è Executar C√≥digo</button>
            <div id="output"></div>
        </div>
    </section>

    <section>
        <h2>üé® Algoritmos de Padr√µes</h2>
        
        <h3>1. Gerador de Sequ√™ncias</h3>
        <pre><code>def sequencia_aritmetica(primeiro, razao, n):
    """Gera progress√£o aritm√©tica"""
    sequencia = []
    termo = primeiro
    
    for i in range(n):
        sequencia.append(termo)
        termo += razao
    
    return sequencia

def sequencia_geometrica(primeiro, razao, n):
    """Gera progress√£o geom√©trica"""
    sequencia = []
    termo = primeiro
    
    for i in range(n):
        sequencia.append(termo)
        termo *= razao
    
    return sequencia

# Teste
print("PA (2, 3, 10 termos):", sequencia_aritmetica(2, 3, 10))
print("PG (2, 3, 8 termos):", sequencia_geometrica(2, 3, 8))</code></pre>
        
        <h3>2. Valida√ß√£o de Padr√µes</h3>
        <pre><code>def eh_palindromo_numerico(numero):
    """Verifica se um n√∫mero √© pal√≠ndromo"""
    str_num = str(numero)
    tamanho = len(str_num)
    
    for i in range(tamanho // 2):
        if str_num[i] != str_num[tamanho - 1 - i]:
            return False
    
    return True

def eh_numero_perfeito(n):
    """Verifica se um n√∫mero √© perfeito (soma dos divisores = n√∫mero)"""
    if n <= 1:
        return False
    
    soma_divisores = 0
    
    for i in range(1, n):
        if n % i == 0:
            soma_divisores += i
    
    return soma_divisores == n

# Teste
print("123 √© pal√≠ndromo?", eh_palindromo_numerico(123))
print("121 √© pal√≠ndromo?", eh_palindromo_numerico(121))
print("6 √© n√∫mero perfeito?", eh_numero_perfeito(6))  # 1+2+3=6
print("28 √© n√∫mero perfeito?", eh_numero_perfeito(28))  # 1+2+4+7+14=28</code></pre>
    </section>

    <section>
        <h2>üèÜ Algoritmos de Otimiza√ß√£o</h2>
        
        <h3>1. Problema da Mochila (vers√£o simples)</h3>
        <pre><code>def mochila_gulosa(pesos, valores, capacidade):
    """Resolve problema da mochila com algoritmo guloso"""
    # Calcular rela√ß√£o valor/peso
    n = len(pesos)
    itens = []
    
    for i in range(n):
        relacao = valores[i] / pesos[i]
        itens.append((relacao, i, pesos[i], valores[i]))
    
    # Ordenar por rela√ß√£o valor/peso (decrescente)
    itens.sort(reverse=True)
    
    peso_total = 0
    valor_total = 0
    itens_selecionados = []
    
    for relacao, idx, peso, valor in itens:
        if peso_total + peso <= capacidade:
            peso_total += peso
            valor_total += valor
            itens_selecionados.append(idx)
    
    return itens_selecionados, peso_total, valor_total

# Teste
pesos = [10, 20, 30]
valores = [60, 100, 120]
capacidade = 50

selecionados, peso, valor = mochila_gulosa(pesos, valores, capacidade)
print(f"Itens selecionados: {selecionados}")
print(f"Peso total: {peso}, Valor total: {valor}")</code></pre>
        
        <h3>2. Busca do Maior Subarray</h3>
        <pre><code>def maior_subarray(lista):
    """Encontra o subarray cont√≠guo com maior soma"""
    if not lista:
        return 0, 0, 0  # soma, inicio, fim
    
    max_soma = lista[0]
    soma_atual = lista[0]
    inicio = 0
    fim = 0
    temp_inicio = 0
    
    for i in range(1, len(lista)):
        if soma_atual < 0:
            soma_atual = lista[i]
            temp_inicio = i
        else:
            soma_atual += lista[i]
        
        if soma_atual > max_soma:
            max_soma = soma_atual
            inicio = temp_inicio
            fim = i
    
    return max_soma, inicio, fim

# Teste
numeros = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
soma, inicio, fim = maior_subarray(numeros)
print(f"Lista: {numeros}")
print(f"Maior subarray: posi√ß√µes {inicio} a {fim}")
print(f"Valores: {numeros[inicio:fim+1]}")
print(f"Soma m√°xima: {soma}")</code></pre>
    </section>

    <section>
        <h2>‚ö° An√°lise de Complexidade</h2>
        
        <table class="complexity-table">
            <tr>
                <th>Algoritmo</th>
                <th>Complexidade de Tempo</th>
                <th>Complexidade de Espa√ßo</th>
            </tr>
            <tr>
                <td>Busca Linear</td>
                <td>O(n)</td>
                <td>O(1)</td>
            </tr>
            <tr>
                <td>Bubble Sort</td>
                <td>O(n¬≤)</td>
                <td>O(1)</td>
            </tr>
            <tr>
                <td>Selection Sort</td>
                <td>O(n¬≤)</td>
                <td>O(1)</td>
            </tr>
            <tr>
                <td>Teste de Primalidade</td>
                <td>O(‚àön)</td>
                <td>O(1)</td>
            </tr>
            <tr>
                <td>Fibonacci (iterativo)</td>
                <td>O(n)</td>
                <td>O(n)</td>
            </tr>
        </table>
    </section>

    <section>
        <h2>üí° Dicas de Otimiza√ß√£o</h2>
        <div class="tip-box">
            <ul>
                <li>üéØ Sempre considere o caso base primeiro</li>
                <li>‚ö° Use break/continue para evitar itera√ß√µes desnecess√°rias</li>
                <li>üìä Para listas grandes, considere algoritmos mais eficientes</li>
                <li>üîç Cache resultados quando poss√≠vel</li>
                <li>üß™ Teste com diferentes tamanhos de entrada</li>
                <li>üìè Me√ßa o tempo de execu√ß√£o para comparar algoritmos</li>
            </ul>
        </div>
    </section>
{% endblock %}

{% block extra_js %}
<script>
function runCode() {
    const code = document.getElementById('code-input').value;
    const output = document.getElementById('output');
    
    output.innerHTML = '<div class="output-success">Kit de algoritmos executado! Teste com diferentes conjuntos de dados.</div>';
}
</script>
{% endblock %}