{% extends "base_aula.html" %}

{% block title %}Aula 8 - Autovalores e Autovetores | CodeLogic{% endblock %}

{% block lesson_title %}Aula 8 ‚Äì Autovalores e Autovetores{% endblock %}

{% block lesson_content %}
    <section>
        <h2>üéØ Objetivo</h2>
        <ul>
            <li>Compreender o conceito de autovalores e autovetores</li>
            <li>Implementar algoritmos de c√°lculo</li>
            <li>Aplicar em an√°lise de componentes principais (PCA)</li>
        </ul>
    </section>

    <section>
        <h2>üî¢ Conceitos Fundamentais</h2>
        <p>Um autovetor de uma matriz √© um vetor que, quando multiplicado pela matriz, resulta em um m√∫ltiplo de si mesmo. O fator de escala √© chamado autovalor.</p>
        
        <div class="formula-box">
            <h3>Equa√ß√£o Caracter√≠stica:</h3>
            <p><strong>A¬∑v = Œª¬∑v</strong></p>
            <p>Onde:</p>
            <ul>
                <li>A = matriz quadrada</li>
                <li>v = autovetor (vetor n√£o-zero)</li>
                <li>Œª = autovalor (escalar)</li>
            </ul>
        </div>
        
        <h3>Implementa√ß√£o do M√©todo da Pot√™ncia:</h3>
        <pre><code>import math
import random

def norma_vetor(vetor):
    """Calcula norma euclidiana de um vetor"""
    return math.sqrt(sum(x**2 for x in vetor))

def normalizar_vetor(vetor):
    """Normaliza vetor para norma unit√°ria"""
    norma = norma_vetor(vetor)
    if norma == 0:
        return vetor
    return [x / norma for x in vetor]

def multiplicar_matriz_vetor(matriz, vetor):
    """Multiplica matriz por vetor"""
    n = len(matriz)
    resultado = [0] * n
    
    for i in range(n):
        for j in range(n):
            resultado[i] += matriz[i][j] * vetor[j]
    
    return resultado

def produto_escalar(v1, v2):
    """Produto escalar entre dois vetores"""
    return sum(a * b for a, b in zip(v1, v2))

def metodo_potencia(matriz, max_iter=1000, tolerancia=1e-6):
    """
    Encontra o maior autovalor e autovetor correspondente
    usando o m√©todo da pot√™ncia
    """
    n = len(matriz)
    
    # Vetor inicial aleat√≥rio
    vetor = [random.random() for _ in range(n)]
    vetor = normalizar_vetor(vetor)
    
    autovalor_anterior = 0
    
    for iteracao in range(max_iter):
        # v_{k+1} = A * v_k
        novo_vetor = multiplicar_matriz_vetor(matriz, vetor)
        
        # Calcular autovalor (quociente de Rayleigh)
        autovalor = produto_escalar(vetor, novo_vetor) / produto_escalar(vetor, vetor)
        
        # Normalizar novo vetor
        novo_vetor = normalizar_vetor(novo_vetor)
        
        # Verificar converg√™ncia
        if abs(autovalor - autovalor_anterior) < tolerancia:
            print(f"Convergiu em {iteracao + 1} itera√ß√µes")
            break
        
        vetor = novo_vetor
        autovalor_anterior = autovalor
    
    return autovalor, vetor

# Exemplo de uso
matriz_exemplo = [
    [4, -2],
    [1,  1]
]

print("Matriz exemplo:")
for linha in matriz_exemplo:
    print(linha)

autovalor, autovetor = metodo_potencia(matriz_exemplo)

print(f"\\nMaior autovalor: {autovalor:.6f}")
print(f"Autovetor correspondente: [{autovetor[0]:.6f}, {autovetor[1]:.6f}]")

# Verifica√ß√£o: A*v deve ser aproximadamente Œª*v
resultado = multiplicar_matriz_vetor(matriz_exemplo, autovetor)
escalar_v = [autovalor * x for x in autovetor]

print(f"\\nVerifica√ß√£o:")
print(f"A*v = [{resultado[0]:.6f}, {resultado[1]:.6f}]")
print(f"Œª*v = [{escalar_v[0]:.6f}, {escalar_v[1]:.6f}]")
print(f"Diferen√ßa: {norma_vetor([a - b for a, b in zip(resultado, escalar_v)]):.8f}")</code></pre>
        
        <h3>M√©todo da Pot√™ncia Inversa:</h3>
        <pre><code>def resolver_sistema_gauss(A, b):
    """Resolve sistema linear Ax = b usando elimina√ß√£o gaussiana"""
    n = len(A)
    
    # Criar matriz aumentada
    M = [linha[:] + [b[i]] for i, linha in enumerate(A)]
    
    # Elimina√ß√£o para frente
    for i in range(n):
        # Pivotamento parcial
        max_linha = i
        for k in range(i + 1, n):
            if abs(M[k][i]) > abs(M[max_linha][i]):
                max_linha = k
        
        M[i], M[max_linha] = M[max_linha], M[i]
        
        # Elimina√ß√£o
        for k in range(i + 1, n):
            if M[i][i] != 0:
                fator = M[k][i] / M[i][i]
                for j in range(i, n + 1):
                    M[k][j] -= fator * M[i][j]
    
    # Substitui√ß√£o para tr√°s
    x = [0] * n
    for i in range(n - 1, -1, -1):
        x[i] = M[i][n]
        for j in range(i + 1, n):
            x[i] -= M[i][j] * x[j]
        if M[i][i] != 0:
            x[i] /= M[i][i]
    
    return x

def subtrair_matriz_escalar(matriz, escalar):
    """Calcula A - œÉI (matriz menos escalar vezes identidade)"""
    n = len(matriz)
    resultado = [linha[:] for linha in matriz]  # C√≥pia
    
    for i in range(n):
        resultado[i][i] -= escalar
    
    return resultado

def potencia_inversa(matriz, sigma=0, max_iter=1000, tolerancia=1e-6):
    """
    Encontra autovalor mais pr√≥ximo de sigma usando pot√™ncia inversa
    """
    n = len(matriz)
    
    # Matriz A - œÉI
    A_shift = subtrair_matriz_escalar(matriz, sigma)
    
    # Vetor inicial
    vetor = [random.random() for _ in range(n)]
    vetor = normalizar_vetor(vetor)
    
    autovalor_anterior = 0
    
    for iteracao in range(max_iter):
        # Resolver (A - œÉI) * v_{k+1} = v_k
        try:
            novo_vetor = resolver_sistema_gauss(A_shift, vetor)
            
            # Normalizar
            novo_vetor = normalizar_vetor(novo_vetor)
            
            # Calcular autovalor
            Av = multiplicar_matriz_vetor(matriz, novo_vetor)
            autovalor = produto_escalar(novo_vetor, Av)
            
            # Verificar converg√™ncia
            if abs(autovalor - autovalor_anterior) < tolerancia:
                print(f"Convergiu em {iteracao + 1} itera√ß√µes")
                break
            
            vetor = novo_vetor
            autovalor_anterior = autovalor
            
        except:
            print("Erro na resolu√ß√£o do sistema - matriz singular")
            break
    
    return autovalor, vetor

# Teste do m√©todo da pot√™ncia inversa
print("\\n" + "="*50)
print("M√âTODO DA POT√äNCIA INVERSA")
print("="*50)

# Procurar autovalor pr√≥ximo de 2
autovalor_inv, autovetor_inv = potencia_inversa(matriz_exemplo, sigma=2)

print(f"Autovalor pr√≥ximo de 2: {autovalor_inv:.6f}")
print(f"Autovetor: [{autovetor_inv[0]:.6f}, {autovetor_inv[1]:.6f}]")</code></pre>
    </section>

    <section>
        <h2>üé® An√°lise de Componentes Principais (PCA)</h2>
        
        <h3>Implementa√ß√£o Completa do PCA:</h3>
        <pre><code>import math

class AnalisePCA:
    """Implementa√ß√£o da An√°lise de Componentes Principais"""
    
    def __init__(self):
        self.dados_originais = None
        self.dados_centrados = None
        self.matriz_covariancia = None
        self.autovalores = []
        self.autovetores = []
        self.componentes_principais = []
        self.variancia_explicada = []
    
    def carregar_dados(self, dados):
        """Carrega dados (lista de listas - cada linha √© uma observa√ß√£o)"""
        self.dados_originais = [linha[:] for linha in dados]
        self.n_observacoes = len(dados)
        self.n_variaveis = len(dados[0])
    
    def centralizar_dados(self):
        """Centraliza dados subtraindo a m√©dia de cada vari√°vel"""
        # Calcular m√©dias
        medias = []
        for j in range(self.n_variaveis):
            soma = sum(self.dados_originais[i][j] for i in range(self.n_observacoes))
            medias.append(soma / self.n_observacoes)
        
        # Centralizar
        self.dados_centrados = []
        for i in range(self.n_observacoes):
            linha_centrada = []
            for j in range(self.n_variaveis):
                linha_centrada.append(self.dados_originais[i][j] - medias[j])
            self.dados_centrados.append(linha_centrada)
        
        self.medias = medias
        return self.dados_centrados
    
    def calcular_matriz_covariancia(self):
        """Calcula matriz de covari√¢ncia"""
        n = self.n_variaveis
        self.matriz_covariancia = [[0 for _ in range(n)] for _ in range(n)]
        
        for i in range(n):
            for j in range(n):
                # Cov(X_i, X_j) = E[(X_i - Œº_i)(X_j - Œº_j)]
                covariancia = 0
                for k in range(self.n_observacoes):
                    covariancia += (self.dados_centrados[k][i] * 
                                  self.dados_centrados[k][j])
                
                self.matriz_covariancia[i][j] = covariancia / (self.n_observacoes - 1)
        
        return self.matriz_covariancia
    
    def encontrar_todos_autovalores(self, max_iter=1000):
        """Encontra todos os autovalores usando defla√ß√£o"""
        n = self.n_variaveis
        matriz_atual = [linha[:] for linha in self.matriz_covariancia]
        
        self.autovalores = []
        self.autovetores = []
        
        for i in range(n):
            # Encontrar maior autovalor da matriz atual
            try:
                autovalor, autovetor = metodo_potencia(matriz_atual, max_iter)
                
                self.autovalores.append(autovalor)
                self.autovetores.append(autovetor)
                
                # Defla√ß√£o: remover este autovalor/autovetor
                matriz_atual = self._deflar_matriz(matriz_atual, autovalor, autovetor)
                
            except:
                # Se falhar, adicionar zeros
                self.autovalores.append(0)
                self.autovetores.append([0] * n)
    
    def _deflar_matriz(self, matriz, autovalor, autovetor):
        """Remove autovalor dominante da matriz"""
        n = len(matriz)
        nova_matriz = [[0 for _ in range(n)] for _ in range(n)]
        
        # A' = A - Œª * v * v^T
        for i in range(n):
            for j in range(n):
                nova_matriz[i][j] = (matriz[i][j] - 
                                   autovalor * autovetor[i] * autovetor[j])
        
        return nova_matriz
    
    def calcular_variancia_explicada(self):
        """Calcula porcentagem de vari√¢ncia explicada por cada componente"""
        variancia_total = sum(self.autovalores)
        
        self.variancia_explicada = []
        variancia_acumulada = 0
        
        for autovalor in self.autovalores:
            porcentagem = (autovalor / variancia_total) * 100
            variancia_acumulada += porcentagem
            
            self.variancia_explicada.append({
                'individual': porcentagem,
                'acumulada': variancia_acumulada
            })
        
        return self.variancia_explicada
    
    def transformar_dados(self, n_componentes=None):
        """Transforma dados para espa√ßo dos componentes principais"""
        if n_componentes is None:
            n_componentes = self.n_variaveis
        
        # Pegar os primeiros n componentes principais
        componentes = self.autovetores[:n_componentes]
        
        # Transformar cada observa√ß√£o
        dados_transformados = []
        for observacao in self.dados_centrados:
            nova_observacao = []
            for componente in componentes:
                # Proje√ß√£o: y = v^T * x
                projecao = produto_escalar(componente, observacao)
                nova_observacao.append(projecao)
            dados_transformados.append(nova_observacao)
        
        return dados_transformados
    
    def executar_pca_completo(self, dados, n_componentes=None):
        """Executa an√°lise PCA completa"""
        print("üîç EXECUTANDO AN√ÅLISE PCA")
        print("=" * 40)
        
        # Passo 1: Carregar e centralizar dados
        self.carregar_dados(dados)
        print(f"Dados carregados: {self.n_observacoes} observa√ß√µes, {self.n_variaveis} vari√°veis")
        
        self.centralizar_dados()
        print("‚úì Dados centralizados")
        
        # Passo 2: Calcular matriz de covari√¢ncia
        self.calcular_matriz_covariancia()
        print("‚úì Matriz de covari√¢ncia calculada")
        
        # Passo 3: Encontrar autovalores e autovetores
        self.encontrar_todos_autovalores()
        print("‚úì Autovalores e autovetores encontrados")
        
        # Passo 4: Calcular vari√¢ncia explicada
        self.calcular_variancia_explicada()
        print("‚úì Vari√¢ncia explicada calculada")
        
        # Passo 5: Transformar dados
        dados_transformados = self.transformar_dados(n_componentes)
        print(f"‚úì Dados transformados para {n_componentes or self.n_variaveis} componentes")
        
        return dados_transformados
    
    def relatorio_pca(self):
        """Gera relat√≥rio detalhado da an√°lise PCA"""
        print("\\nüìä RELAT√ìRIO PCA")
        print("=" * 50)
        
        print("\\nüî¢ AUTOVALORES E VARI√ÇNCIA EXPLICADA:")
        for i, (autovalor, variancia) in enumerate(zip(self.autovalores, self.variancia_explicada)):
            print(f"  PC{i+1}: Œª={autovalor:.4f}, "
                  f"Var.Ind.={variancia['individual']:.1f}%, "
                  f"Var.Acum.={variancia['acumulada']:.1f}%")
        
        print("\\nüéØ AUTOVETORES (Componentes Principais):")
        for i, autovetor in enumerate(self.autovetores):
            componentes_str = ", ".join([f"{x:.3f}" for x in autovetor])
            print(f"  PC{i+1}: [{componentes_str}]")
        
        print("\\nüìà MATRIZ DE COVARI√ÇNCIA:")
        for linha in self.matriz_covariancia:
            linha_str = ", ".join([f"{x:7.3f}" for x in linha])
            print(f"  [{linha_str}]")
        
        # Sugest√£o de n√∫mero de componentes (crit√©rio de Kaiser: Œª > 1)
        componentes_significativos = sum(1 for Œª in self.autovalores if Œª > 1)
        print(f"\\nüí° SUGEST√ÉO: Usar {componentes_significativos} componentes (crit√©rio Œª > 1)")
        
        # Encontrar quantos componentes explicam 95% da vari√¢ncia
        for i, variancia in enumerate(self.variancia_explicada):
            if variancia['acumulada'] >= 95:
                print(f"üí° ALTERNATIVA: {i+1} componentes explicam 95% da vari√¢ncia")
                break

# Exemplo pr√°tico: an√°lise de dados de estudantes
dados_estudantes = [
    # [Matem√°tica, F√≠sica, Qu√≠mica, Hist√≥ria, Literatura]
    [85, 82, 78, 70, 72],
    [90, 88, 85, 65, 68],
    [78, 75, 80, 85, 88],
    [92, 89, 86, 68, 70],
    [76, 72, 74, 82, 85],
    [88, 85, 83, 72, 75],
    [82, 78, 79, 88, 90],
    [86, 83, 81, 75, 78],
    [79, 76, 77, 86, 89],
    [91, 87, 84, 69, 71]
]

print("AN√ÅLISE PCA: DESEMPENHO DE ESTUDANTES")
print("=====================================")
print("Vari√°veis: Matem√°tica, F√≠sica, Qu√≠mica, Hist√≥ria, Literatura")

# Executar PCA
pca = AnalisePCA()
dados_reduzidos = pca.executar_pca_completo(dados_estudantes, n_componentes=2)

# Gerar relat√≥rio
pca.relatorio_pca()

print("\\nüéØ DADOS TRANSFORMADOS (Primeiros 2 Componentes):")
for i, observacao in enumerate(dados_reduzidos):
    print(f"  Estudante {i+1}: PC1={observacao[0]:.3f}, PC2={observacao[1]:.3f}")

print("\\nüß† INTERPRETA√á√ÉO:")
print("PC1 (Primeira Componente Principal):")
pc1 = pca.autovetores[0]
if abs(pc1[0]) > 0.3 and abs(pc1[1]) > 0.3 and abs(pc1[2]) > 0.3:
    print("  - Representa habilidade geral em ci√™ncias exatas")
if abs(pc1[3]) > 0.3 and abs(pc1[4]) > 0.3:
    print("  - Relacionada com humanidades")

print("\\nPC2 (Segunda Componente Principal):")
pc2 = pca.autovetores[1]
print("  - Representa contraste entre diferentes √°reas do conhecimento")</code></pre>
    </section>

    <section>
        <h2>üéÆ Exerc√≠cio Pr√°tico</h2>
        <div class="exercise-box">
            <h3>Sistema de Recomenda√ß√£o com Redu√ß√£o de Dimensionalidade</h3>
            <p>Implemente um sistema que usa PCA para reduzir dimensionalidade em dados de prefer√™ncias de usu√°rios:</p>
            <ul>
                <li>An√°lise de padr√µes de consumo</li>
                <li>Redu√ß√£o de dimensionalidade</li>
                <li>Sistema de recomenda√ß√£o baseado em similaridade</li>
            </ul>
            
            <textarea id="code-input" placeholder="import math
import random

class SistemaRecomendacaoPCA:
    '''Sistema de recomenda√ß√£o usando PCA para redu√ß√£o de dimensionalidade'''
    
    def __init__(self):
        self.usuarios = []
        self.produtos = []
        self.matriz_avaliacoes = []
        self.pca = AnalisePCA()
        self.dados_reduzidos = None
        self.matriz_similaridade = None
    
    def carregar_dados_avaliacoes(self, usuarios, produtos, avaliacoes):
        '''Carrega dados de avalia√ß√µes dos usu√°rios'''
        self.usuarios = usuarios[:]
        self.produtos = produtos[:]
        self.matriz_avaliacoes = [linha[:] for linha in avaliacoes]
    
    def executar_reducao_dimensionalidade(self, n_componentes=3):
        '''Executa PCA para reduzir dimensionalidade dos dados'''
        print('üîç EXECUTANDO REDU√á√ÉO DE DIMENSIONALIDADE')
        print('=' * 45)
        
        # Executar PCA nos dados de avalia√ß√µes
        self.dados_reduzidos = self.pca.executar_pca_completo(
            self.matriz_avaliacoes, n_componentes
        )
        
        # Mostrar resultados do PCA
        self.pca.relatorio_pca()
        
        return self.dados_reduzidos
    
    def calcular_similaridade_cosseno(self, vetor1, vetor2):
        '''Calcula similaridade do cosseno entre dois vetores'''
        produto_escalar = sum(a * b for a, b in zip(vetor1, vetor2))
        
        norma1 = math.sqrt(sum(x**2 for x in vetor1))
        norma2 = math.sqrt(sum(x**2 for x in vetor2))
        
        if norma1 == 0 or norma2 == 0:
            return 0
        
        return produto_escalar / (norma1 * norma2)
    
    def construir_matriz_similaridade(self):
        '''Constr√≥i matriz de similaridade entre usu√°rios'''
        n_usuarios = len(self.usuarios)
        self.matriz_similaridade = [[0 for _ in range(n_usuarios)] 
                                  for _ in range(n_usuarios)]
        
        for i in range(n_usuarios):
            for j in range(i, n_usuarios):
                if i == j:
                    similaridade = 1.0
                else:
                    similaridade = self.calcular_similaridade_cosseno(
                        self.dados_reduzidos[i], 
                        self.dados_reduzidos[j]
                    )
                
                self.matriz_similaridade[i][j] = similaridade
                self.matriz_similaridade[j][i] = similaridade
        
        return self.matriz_similaridade
    
    def encontrar_usuarios_similares(self, usuario_alvo, n_similares=3):
        '''Encontra usu√°rios mais similares ao usu√°rio alvo'''
        if usuario_alvo not in self.usuarios:
            return []
        
        idx_alvo = self.usuarios.index(usuario_alvo)
        
        # Pegar similaridades (excluindo o pr√≥prio usu√°rio)
        similaridades = []
        for i, similaridade in enumerate(self.matriz_similaridade[idx_alvo]):
            if i != idx_alvo:
                similaridades.append((i, similaridade))
        
        # Ordenar por similaridade (maior primeiro)
        similaridades.sort(key=lambda x: x[1], reverse=True)
        
        # Retornar os N mais similares
        usuarios_similares = []
        for i, similaridade in similaridades[:n_similares]:
            usuarios_similares.append((self.usuarios[i], similaridade))
        
        return usuarios_similares
    
    def recomendar_produtos(self, usuario_alvo, n_recomendacoes=3):
        '''Recomenda produtos baseado em usu√°rios similares'''
        if usuario_alvo not in self.usuarios:
            return []
        
        idx_alvo = self.usuarios.index(usuario_alvo)
        
        # Encontrar usu√°rios similares
        usuarios_similares = self.encontrar_usuarios_similares(usuario_alvo, 5)
        
        # Calcular pontua√ß√µes para produtos n√£o avaliados
        pontuacoes_produtos = {}
        avaliacoes_alvo = self.matriz_avaliacoes[idx_alvo]
        
        for idx_produto, produto in enumerate(self.produtos):
            # Se usu√°rio j√° avaliou, pular
            if avaliacoes_alvo[idx_produto] > 0:
                continue
            
            pontuacao_total = 0
            peso_total = 0
            
            # Agregar avalia√ß√µes de usu√°rios similares
            for usuario_similar, similaridade in usuarios_similares:
                idx_similar = self.usuarios.index(usuario_similar)
                avaliacao_similar = self.matriz_avaliacoes[idx_similar][idx_produto]
                
                if avaliacao_similar > 0:  # Se usu√°rio similar avaliou
                    pontuacao_total += avaliacao_similar * similaridade
                    peso_total += similaridade
            
            # Calcular pontua√ß√£o m√©dia ponderada
            if peso_total > 0:
                pontuacoes_produtos[produto] = pontuacao_total / peso_total
        
        # Ordenar produtos por pontua√ß√£o
        produtos_ordenados = sorted(pontuacoes_produtos.items(), 
                                  key=lambda x: x[1], reverse=True)
        
        return produtos_ordenados[:n_recomendacoes]
    
    def analisar_perfil_usuario(self, usuario):
        '''Analisa perfil do usu√°rio no espa√ßo reduzido'''
        if usuario not in self.usuarios:
            return None
        
        idx_usuario = self.usuarios.index(usuario)
        perfil_reduzido = self.dados_reduzidos[idx_usuario]
        
        # Interpretar componentes principais
        interpretacao = []
        
        for i, valor in enumerate(perfil_reduzido):
            if valor > 0.5:
                interpretacao.append(f'PC{i+1}: Alto ({valor:.3f})')
            elif valor < -0.5:
                interpretacao.append(f'PC{i+1}: Baixo ({valor:.3f})')
            else:
                interpretacao.append(f'PC{i+1}: M√©dio ({valor:.3f})')
        
        return {
            'usuario': usuario,
            'perfil_original': self.matriz_avaliacoes[idx_usuario],
            'perfil_reduzido': perfil_reduzido,
            'interpretacao': interpretacao
        }
    
    def estatisticas_sistema(self):
        '''Calcula estat√≠sticas do sistema de recomenda√ß√£o'''
        n_usuarios = len(self.usuarios)
        n_produtos = len(self.produtos)
        
        # Calcular esparsidade da matriz
        total_avaliacoes = sum(
            sum(1 for avaliacao in linha if avaliacao > 0)
            for linha in self.matriz_avaliacoes
        )
        
        total_possivel = n_usuarios * n_produtos
        densidade = (total_avaliacoes / total_possivel) * 100
        esparsidade = 100 - densidade
        
        # Distribui√ß√£o de avalia√ß√µes
        todas_avaliacoes = [
            avaliacao for linha in self.matriz_avaliacoes 
            for avaliacao in linha if avaliacao > 0
        ]
        
        if todas_avaliacoes:
            media_avaliacoes = sum(todas_avaliacoes) / len(todas_avaliacoes)
            min_avaliacao = min(todas_avaliacoes)
            max_avaliacao = max(todas_avaliacoes)
        else:
            media_avaliacoes = min_avaliacao = max_avaliacao = 0
        
        return {
            'usuarios': n_usuarios,
            'produtos': n_produtos,
            'avaliacoes_total': total_avaliacoes,
            'densidade': densidade,
            'esparsidade': esparsidade,
            'media_avaliacoes': media_avaliacoes,
            'min_avaliacao': min_avaliacao,
            'max_avaliacao': max_avaliacao,
            'variancia_explicada': self.pca.variancia_explicada if self.pca.variancia_explicada else []
        }
    
    def visualizar_similaridades(self):
        '''Exibe matriz de similaridade de forma leg√≠vel'''
        print('\\nüîó MATRIZ DE SIMILARIDADE ENTRE USU√ÅRIOS:')
        print('=' * 50)
        
        # Cabe√ßalho
        header = '    '
        for usuario in self.usuarios:
            header += f'{usuario[:4]:>6}'
        print(header)
        
        # Linhas da matriz
        for i, usuario in enumerate(self.usuarios):
            linha = f'{usuario[:4]:>4}'
            for j in range(len(self.usuarios)):
                linha += f'{self.matriz_similaridade[i][j]:6.3f}'
            print(linha)

# Dados de exemplo: usu√°rios e suas avalia√ß√µes de filmes (1-5)
usuarios_exemplo = ['Alice', 'Bob', 'Carol', 'David', 'Eva', 'Frank']

filmes_exemplo = [
    'A√ß√£o_1', 'A√ß√£o_2', 'Com√©dia_1', 'Com√©dia_2', 
    'Drama_1', 'Drama_2', 'Fic√ß√£o_1', 'Fic√ß√£o_2'
]

# Matriz de avalia√ß√µes (0 = n√£o avaliado, 1-5 = nota)
avaliacoes_exemplo = [
    [5, 4, 0, 2, 3, 0, 5, 4],  # Alice - gosta de a√ß√£o e fic√ß√£o
    [4, 5, 1, 0, 2, 1, 4, 5],  # Bob - similar √† Alice
    [0, 1, 5, 4, 5, 4, 0, 1],  # Carol - gosta de com√©dia e drama
    [1, 0, 4, 5, 4, 5, 2, 0],  # David - similar √† Carol
    [3, 3, 3, 3, 3, 3, 3, 3],  # Eva - m√©dio em tudo
    [5, 5, 0, 0, 0, 0, 5, 5]   # Frank - s√≥ a√ß√£o e fic√ß√£o
]

print('üé¨ SISTEMA DE RECOMENDA√á√ÉO DE FILMES COM PCA')
print('=' * 50)

# Criar e configurar sistema
sistema = SistemaRecomendacaoPCA()
sistema.carregar_dados_avaliacoes(usuarios_exemplo, filmes_exemplo, avaliacoes_exemplo)

print(f'Usu√°rios: {usuarios_exemplo}')
print(f'Filmes: {filmes_exemplo}')
print('\\nMatriz de Avalia√ß√µes (0=n√£o avaliado, 1-5=nota):')
for i, usuario in enumerate(usuarios_exemplo):
    print(f'{usuario:>6}: {avaliacoes_exemplo[i]}')

# Executar redu√ß√£o de dimensionalidade
dados_reduzidos = sistema.executar_reducao_dimensionalidade(n_componentes=3)

# Construir matriz de similaridade
sistema.construir_matriz_similaridade()

# Visualizar similaridades
sistema.visualizar_similaridades()

print('\\nüë• AN√ÅLISE DE USU√ÅRIOS SIMILARES:')
print('=' * 35)

for usuario in usuarios_exemplo[:3]:  # Apenas primeiros 3 para economizar espa√ßo
    similares = sistema.encontrar_usuarios_similares(usuario, 2)
    print(f'\\n{usuario} √© similar a:')
    for usuario_similar, similaridade in similares:
        print(f'  {usuario_similar}: {similaridade:.3f}')

print('\\nüéØ RECOMENDA√á√ïES PERSONALIZADAS:')
print('=' * 35)

for usuario in usuarios_exemplo[:3]:  # Apenas primeiros 3
    recomendacoes = sistema.recomendar_produtos(usuario, 2)
    print(f'\\nRecomenda√ß√µes para {usuario}:')
    
    if recomendacoes:
        for filme, pontuacao in recomendacoes:
            print(f'  {filme}: {pontuacao:.2f}')
    else:
        print('  Nenhuma recomenda√ß√£o dispon√≠vel')

print('\\nüìä AN√ÅLISE DE PERFIS DOS USU√ÅRIOS:')
print('=' * 35)

for usuario in usuarios_exemplo[:3]:  # Apenas primeiros 3
    perfil = sistema.analisar_perfil_usuario(usuario)
    print(f'\\n{usuario}:')
    print(f'  Perfil original: {perfil[\"perfil_original\"]}')
    print(f'  Perfil reduzido: {[f\"{x:.3f}\" for x in perfil[\"perfil_reduzido\"]]}')
    print(f'  Interpreta√ß√£o: {perfil[\"interpretacao\"]}')

print('\\nüìà ESTAT√çSTICAS DO SISTEMA:')
print('=' * 30)

stats = sistema.estatisticas_sistema()
print(f'Usu√°rios: {stats[\"usuarios\"]}')
print(f'Produtos: {stats[\"produtos\"]}')
print(f'Avalia√ß√µes totais: {stats[\"avaliacoes_total\"]}')
print(f'Densidade da matriz: {stats[\"densidade\"]:.1f}%')
print(f'Esparsidade: {stats[\"esparsidade\"]:.1f}%')
print(f'M√©dia das avalia√ß√µes: {stats[\"media_avaliacoes\"]:.2f}')

if stats['variancia_explicada']:
    print('\\nVari√¢ncia explicada por componente:')
    for i, var in enumerate(stats['variancia_explicada']):
        print(f'  PC{i+1}: {var[\"individual\"]:.1f}% (Acum: {var[\"acumulada\"]:.1f}%)')

print('\\nüí° INTERPRETA√á√ÉO DOS RESULTADOS:')
print('=' * 35)
print('- PC1 pode representar prefer√™ncia por g√™neros de a√ß√£o/aventura vs drama/com√©dia')
print('- PC2 pode representar toler√¢ncia a diferentes tipos de conte√∫do')
print('- PC3 pode capturar nuances espec√≠ficas de gosto pessoal')
print('\\nO sistema usa essas dimens√µes reduzidas para encontrar usu√°rios')
print('com perfis similares e fazer recomenda√ß√µes baseadas em suas prefer√™ncias.')"></textarea>
            
            <button onclick="runCode()" class="btn-run">‚ñ∂Ô∏è Executar C√≥digo</button>
            <div id="output"></div>
        </div>
    </section>

    <section>
        <h2>üìä Aplica√ß√µes Pr√°ticas</h2>
        
        <div class="applications-grid">
            <div class="app-card">
                <h3>üîç An√°lise de Dados</h3>
                <ul>
                    <li>Redu√ß√£o de dimensionalidade</li>
                    <li>Visualiza√ß√£o de dados complexos</li>
                    <li>Detec√ß√£o de padr√µes</li>
                </ul>
            </div>
            
            <div class="app-card">
                <h3>ü§ñ Machine Learning</h3>
                <ul>
                    <li>Pr√©-processamento de features</li>
                    <li>Remo√ß√£o de ru√≠do</li>
                    <li>Compress√£o de dados</li>
                </ul>
            </div>
            
            <div class="app-card">
                <h3>üé® Processamento de Imagens</h3>
                <ul>
                    <li>Compress√£o de imagens</li>
                    <li>Reconhecimento facial</li>
                    <li>An√°lise de textura</li>
                </ul>
            </div>
            
            <div class="app-card">
                <h3>üìà An√°lise Financeira</h3>
                <ul>
                    <li>An√°lise de portf√≥lio</li>
                    <li>Gerenciamento de risco</li>
                    <li>Identifica√ß√£o de fatores</li>
                </ul>
            </div>
        </div>
    </section>

    <section>
        <h2>‚ö° Otimiza√ß√µes Avan√ßadas</h2>
        
        <h3>Algoritmo QR para Autovalores:</h3>
        <pre><code>def algoritmo_qr_autovalores(matriz, max_iter=1000, tolerancia=1e-10):
    """
    Algoritmo QR para encontrar todos os autovalores
    (Implementa√ß√£o simplificada - conceitual)
    """
    n = len(matriz)
    A = [linha[:] for linha in matriz]  # C√≥pia
    
    for iteracao in range(max_iter):
        # Decomposi√ß√£o QR (Gram-Schmidt simplificado)
        Q, R = decomposicao_qr_simplificada(A)
        
        # A_{k+1} = R * Q
        A = multiplicar_matrizes(R, Q)
        
        # Verificar converg√™ncia (elementos abaixo da diagonal)
        soma_offdiag = sum(abs(A[i][j]) for i in range(n) for j in range(i))
        
        if soma_offdiag < tolerancia:
            print(f"QR convergiu em {iteracao + 1} itera√ß√µes")
            break
    
    # Autovalores s√£o os elementos da diagonal
    autovalores = [A[i][i] for i in range(n)]
    return autovalores

def decomposicao_qr_simplificada(A):
    """Decomposi√ß√£o QR usando Gram-Schmidt modificado"""
    n = len(A)
    Q = [[0 for _ in range(n)] for _ in range(n)]
    R = [[0 for _ in range(n)] for _ in range(n)]
    
    # Processo de Gram-Schmidt
    for j in range(n):
        # Copiar coluna j de A
        v = [A[i][j] for i in range(n)]
        
        # Ortogonalizar contra colunas anteriores de Q
        for i in range(j):
            R[i][j] = produto_escalar([Q[k][i] for k in range(n)], v)
            for k in range(n):
                v[k] -= R[i][j] * Q[k][i]
        
        # Normalizar
        R[j][j] = norma_vetor(v)
        if R[j][j] > 0:
            for i in range(n):
                Q[i][j] = v[i] / R[j][j]
    
    return Q, R

def multiplicar_matrizes(A, B):
    """Multiplica duas matrizes"""
    n = len(A)
    C = [[0 for _ in range(n)] for _ in range(n)]
    
    for i in range(n):
        for j in range(n):
            for k in range(n):
                C[i][j] += A[i][k] * B[k][j]
    
    return C

# Teste do algoritmo QR
print("\\nTeste do Algoritmo QR:")
matriz_teste = [
    [4, 1],
    [1, 3]
]

autovalores_qr = algoritmo_qr_autovalores(matriz_teste)
print(f"Autovalores (QR): {[f'{x:.6f}' for x in autovalores_qr]}")

# Comparar com m√©todo da pot√™ncia
autovalor_max, _ = metodo_potencia(matriz_teste)
print(f"Maior autovalor (Pot√™ncia): {autovalor_max:.6f}")</code></pre>
    </section>

    <section>
        <h2>üí° Dicas de Performance</h2>
        <div class="tip-box">
            <ul>
                <li>üéØ <strong>Use m√©todos espec√≠ficos</strong> - Pot√™ncia para maior, Pot√™ncia Inversa para espec√≠fico</li>
                <li>‚ö° <strong>Aproveite estrutura</strong> - Matrizes sim√©tricas t√™m autovetores ortogonais</li>
                <li>üß† <strong>Defla√ß√£o cuidadosa</strong> - Erros num√©ricos podem se acumular</li>
                <li>üìä <strong>Valida√ß√£o necess√°ria</strong> - Sempre verifique A¬∑v = Œª¬∑v</li>
                <li>üîß <strong>Use bibliotecas</strong> - NumPy/SciPy para produ√ß√£o</li>
                <li>üíæ <strong>Considere esparsidade</strong> - Algoritmos especiais para matrizes esparsas</li>
            </ul>
        </div>
    </section>
{% endblock %}

{% block extra_js %}
<script>
function runCode() {
    const code = document.getElementById('code-input').value;
    const output = document.getElementById('output');
    
    output.innerHTML = '<div class="output-success">Sistema de recomenda√ß√£o com PCA executado! Veja como autovalores e autovetores reduzem dimensionalidade mantendo informa√ß√£o essencial.</div>';
}
</script>
{% endblock %}