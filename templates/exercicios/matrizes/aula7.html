{% extends "base_aula.html" %}

{% block title %}Aula 7 - Matrizes Esparsas e Otimiza√ß√£o | CodeLogic{% endblock %}

{% block lesson_title %}Aula 7 ‚Äì Matrizes Esparsas e Otimiza√ß√£o{% endblock %}

{% block lesson_content %}
    <section>
        <h2>üéØ Objetivo</h2>
        <ul>
            <li>Compreender o conceito de matrizes esparsas</li>
            <li>Implementar representa√ß√µes eficientes</li>
            <li>Otimizar opera√ß√µes com grandes matrizes</li>
        </ul>
    </section>

    <section>
        <h2>üìà Matrizes Esparsas</h2>
        <p>Matrizes esparsas s√£o matrizes que cont√™m principalmente zeros. Para economizar mem√≥ria e melhorar performance, usamos representa√ß√µes especiais.</p>
        
        <h3>Representa√ß√£o por Coordenadas (COO):</h3>
        <pre><code>class MatrizEsparsaCOO:
    """Matriz esparsa usando formato COO (Coordinate)"""
    
    def __init__(self, linhas, colunas):
        self.linhas = linhas
        self.colunas = colunas
        self.dados = []  # Lista de (linha, coluna, valor)
    
    def adicionar(self, linha, coluna, valor):
        """Adiciona elemento n√£o-zero"""
        if valor != 0:
            self.dados.append((linha, coluna, valor))
    
    def obter(self, linha, coluna):
        """Obt√©m valor em posi√ß√£o espec√≠fica"""
        for l, c, v in self.dados:
            if l == linha and c == coluna:
                return v
        return 0
    
    def para_matriz_densa(self):
        """Converte para matriz densa (lista de listas)"""
        matriz = [[0 for _ in range(self.colunas)] for _ in range(self.linhas)]
        
        for linha, coluna, valor in self.dados:
            matriz[linha][coluna] = valor
        
        return matriz
    
    def densidade(self):
        """Calcula densidade da matriz (% de elementos n√£o-zero)"""
        total_elementos = self.linhas * self.colunas
        elementos_nao_zero = len(self.dados)
        return (elementos_nao_zero / total_elementos) * 100
    
    def __str__(self):
        return f"MatrizEsparsaCOO({self.linhas}x{self.colunas}, {len(self.dados)} elementos)"

# Exemplo de uso
matriz_esparsa = MatrizEsparsaCOO(5, 5)

# Adicionar apenas elementos n√£o-zero
elementos = [(0, 0, 10), (1, 2, 20), (2, 1, 30), (3, 3, 40), (4, 4, 50)]
for l, c, v in elementos:
    matriz_esparsa.adicionar(l, c, v)

print(f"Matriz esparsa: {matriz_esparsa}")
print(f"Densidade: {matriz_esparsa.densidade():.1f}%")

# Converter para matriz densa para visualiza√ß√£o
densa = matriz_esparsa.para_matriz_densa()
print("\\nMatriz densa:")
for linha in densa:
    print(linha)</code></pre>
        
        <h3>Representa√ß√£o CSR (Compressed Sparse Row):</h3>
        <pre><code>class MatrizEsparsaCSR:
    """Matriz esparsa usando formato CSR (Compressed Sparse Row)"""
    
    def __init__(self, matriz_densa=None):
        self.linhas = 0
        self.colunas = 0
        self.valores = []      # Valores n√£o-zero
        self.indices_colunas = []  # √çndices das colunas
        self.ponteiros_linhas = [0]  # Ponteiros para in√≠cio de cada linha
        
        if matriz_densa:
            self._de_matriz_densa(matriz_densa)
    
    def _de_matriz_densa(self, matriz):
        """Converte matriz densa para CSR"""
        self.linhas = len(matriz)
        self.colunas = len(matriz[0])
        
        for i in range(self.linhas):
            for j in range(self.colunas):
                if matriz[i][j] != 0:
                    self.valores.append(matriz[i][j])
                    self.indices_colunas.append(j)
            
            # Adicionar ponteiro para pr√≥xima linha
            self.ponteiros_linhas.append(len(self.valores))
    
    def obter(self, linha, coluna):
        """Obt√©m valor em posi√ß√£o espec√≠fica"""
        inicio = self.ponteiros_linhas[linha]
        fim = self.ponteiros_linhas[linha + 1]
        
        for k in range(inicio, fim):
            if self.indices_colunas[k] == coluna:
                return self.valores[k]
        
        return 0
    
    def multiplicar_vetor(self, vetor):
        """Multiplica matriz por vetor de forma eficiente"""
        if len(vetor) != self.colunas:
            raise ValueError("Dimens√µes incompat√≠veis")
        
        resultado = [0] * self.linhas
        
        for i in range(self.linhas):
            inicio = self.ponteiros_linhas[i]
            fim = self.ponteiros_linhas[i + 1]
            
            for k in range(inicio, fim):
                j = self.indices_colunas[k]
                resultado[i] += self.valores[k] * vetor[j]
        
        return resultado
    
    def para_matriz_densa(self):
        """Converte para matriz densa"""
        matriz = [[0 for _ in range(self.colunas)] for _ in range(self.linhas)]
        
        for i in range(self.linhas):
            inicio = self.ponteiros_linhas[i]
            fim = self.ponteiros_linhas[i + 1]
            
            for k in range(inicio, fim):
                j = self.indices_colunas[k]
                matriz[i][j] = self.valores[k]
        
        return matriz
    
    def estatisticas(self):
        """Retorna estat√≠sticas da matriz"""
        total_elementos = self.linhas * self.colunas
        elementos_nao_zero = len(self.valores)
        
        return {
            'dimensoes': (self.linhas, self.colunas),
            'elementos_nao_zero': elementos_nao_zero,
            'densidade': (elementos_nao_zero / total_elementos) * 100,
            'economia_memoria': ((total_elementos - elementos_nao_zero) / total_elementos) * 100
        }

# Exemplo - matriz tridiagonal
matriz_densa = [
    [2, -1, 0, 0, 0],
    [-1, 2, -1, 0, 0],
    [0, -1, 2, -1, 0],
    [0, 0, -1, 2, -1],
    [0, 0, 0, -1, 2]
]

csr = MatrizEsparsaCSR(matriz_densa)
stats = csr.estatisticas()

print("Estat√≠sticas da matriz CSR:")
for chave, valor in stats.items():
    if isinstance(valor, float):
        print(f"  {chave}: {valor:.1f}%")
    else:
        print(f"  {chave}: {valor}")

# Teste de multiplica√ß√£o por vetor
vetor = [1, 2, 3, 4, 5]
resultado = csr.multiplicar_vetor(vetor)
print(f"\\nMultiplica√ß√£o por vetor {vetor}:")
print(f"Resultado: {resultado}")</code></pre>
    </section>

    <section>
        <h2>‚ö° Otimiza√ß√µes de Performance</h2>
        
        <h3>Cache-Friendly Matrix Operations:</h3>
        <pre><code>import time

def multiplicar_matrizes_naive(A, B):
    """Multiplica√ß√£o naive (ordem i,j,k)"""
    n = len(A)
    C = [[0 for _ in range(n)] for _ in range(n)]
    
    for i in range(n):
        for j in range(n):
            for k in range(n):
                C[i][j] += A[i][k] * B[k][j]
    
    return C

def multiplicar_matrizes_otimizada(A, B):
    """Multiplica√ß√£o otimizada (ordem i,k,j)"""
    n = len(A)
    C = [[0 for _ in range(n)] for _ in range(n)]
    
    for i in range(n):
        for k in range(n):
            for j in range(n):
                C[i][j] += A[i][k] * B[k][j]
    
    return C

def multiplicar_por_blocos(A, B, tamanho_bloco=64):
    """Multiplica√ß√£o por blocos para melhor uso de cache"""
    n = len(A)
    C = [[0 for _ in range(n)] for _ in range(n)]
    
    for i in range(0, n, tamanho_bloco):
        for j in range(0, n, tamanho_bloco):
            for k in range(0, n, tamanho_bloco):
                # Multiplicar blocos
                for ii in range(i, min(i + tamanho_bloco, n)):
                    for kk in range(k, min(k + tamanho_bloco, n)):
                        for jj in range(j, min(j + tamanho_bloco, n)):
                            C[ii][jj] += A[ii][kk] * B[kk][jj]
    
    return C

def benchmark_multiplicacao(tamanho=100):
    """Compara performance dos algoritmos"""
    import random
    
    # Criar matrizes de teste
    A = [[random.randint(1, 10) for _ in range(tamanho)] for _ in range(tamanho)]
    B = [[random.randint(1, 10) for _ in range(tamanho)] for _ in range(tamanho)]
    
    print(f"Benchmark multiplica√ß√£o {tamanho}x{tamanho}:")
    
    # Teste m√©todo naive
    inicio = time.time()
    C1 = multiplicar_matrizes_naive(A, B)
    tempo_naive = time.time() - inicio
    print(f"  Naive: {tempo_naive:.3f}s")
    
    # Teste m√©todo otimizado
    inicio = time.time()
    C2 = multiplicar_matrizes_otimizada(A, B)
    tempo_otimizado = time.time() - inicio
    print(f"  Otimizado: {tempo_otimizado:.3f}s")
    
    # Teste por blocos
    inicio = time.time()
    C3 = multiplicar_por_blocos(A, B, 32)
    tempo_blocos = time.time() - inicio
    print(f"  Por blocos: {tempo_blocos:.3f}s")
    
    speedup_otimizado = tempo_naive / tempo_otimizado
    speedup_blocos = tempo_naive / tempo_blocos
    
    print(f"  Speedup otimizado: {speedup_otimizado:.2f}x")
    print(f"  Speedup blocos: {speedup_blocos:.2f}x")

# Executar benchmark (descomente para testar)
# benchmark_multiplicacao(50)</code></pre>
        
        <h3>Opera√ß√µes In-Place:</h3>
        <pre><code>def transposta_in_place(matriz):
    """Transposta in-place para matrizes quadradas"""
    n = len(matriz)
    
    for i in range(n):
        for j in range(i + 1, n):
            # Trocar elementos sim√©tricos
            matriz[i][j], matriz[j][i] = matriz[j][i], matriz[i][j]

def rotacionar_90_in_place(matriz):
    """Rotaciona matriz 90¬∞ in-place"""
    n = len(matriz)
    
    # Primeiro: transpor
    transposta_in_place(matriz)
    
    # Segundo: reverter cada linha
    for i in range(n):
        matriz[i].reverse()

# Teste
teste_matriz = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

print("Matriz original:")
for linha in teste_matriz:
    print(linha)

rotacionar_90_in_place(teste_matriz)

print("\\nAp√≥s rota√ß√£o 90¬∞:")
for linha in teste_matriz:
    print(linha)</code></pre>
    </section>

    <section>
        <h2>üéÆ Exerc√≠cio Pr√°tico</h2>
        <div class="exercise-box">
            <h3>Sistema de An√°lise de Redes Sociais</h3>
            <p>Implemente um sistema que usa matrizes esparsas para analisar redes sociais:</p>
            <ul>
                <li>Matriz de adjac√™ncia para representar conex√µes</li>
                <li>C√°lculo de m√©tricas de centralidade</li>
                <li>Detec√ß√£o de comunidades</li>
            </ul>
            
            <textarea id="code-input" placeholder="import random
from collections import defaultdict, deque

class AnalisadorRedeSocial:
    def __init__(self):
        '''Sistema para an√°lise de redes sociais usando matrizes esparsas'''
        self.usuarios = []
        self.matriz_adjacencia = None
        self.conexoes = defaultdict(set)
    
    def adicionar_usuario(self, nome):
        '''Adiciona usu√°rio √† rede'''
        if nome not in self.usuarios:
            self.usuarios.append(nome)
            return len(self.usuarios) - 1
        return self.usuarios.index(nome)
    
    def adicionar_conexao(self, usuario1, usuario2):
        '''Adiciona conex√£o bidirecional entre usu√°rios'''
        idx1 = self.adicionar_usuario(usuario1)
        idx2 = self.adicionar_usuario(usuario2)
        
        self.conexoes[idx1].add(idx2)
        self.conexoes[idx2].add(idx1)
    
    def construir_matriz_adjacencia(self):
        '''Constr√≥i matriz de adjac√™ncia esparsa'''
        n = len(self.usuarios)
        self.matriz_adjacencia = MatrizEsparsaCOO(n, n)
        
        for usuario, conexoes in self.conexoes.items():
            for conexao in conexoes:
                self.matriz_adjacencia.adicionar(usuario, conexao, 1)
    
    def calcular_grau(self, usuario):
        '''Calcula grau (n√∫mero de conex√µes) de um usu√°rio'''
        if isinstance(usuario, str):
            usuario = self.usuarios.index(usuario)
        
        return len(self.conexoes[usuario])
    
    def centralidade_grau(self):
        '''Calcula centralidade de grau para todos os usu√°rios'''
        centralidades = {}
        n = len(self.usuarios)
        
        for i, usuario in enumerate(self.usuarios):
            grau = self.calcular_grau(i)
            # Normalizar pelo n√∫mero m√°ximo poss√≠vel de conex√µes
            centralidades[usuario] = grau / (n - 1) if n > 1 else 0
        
        return centralidades
    
    def centralidade_proximidade(self):
        '''Calcula centralidade de proximidade (baseada em dist√¢ncias)'''
        centralidades = {}
        n = len(self.usuarios)
        
        for i, usuario in enumerate(self.usuarios):
            distancias = self._bfs_distancias(i)
            
            # Soma das dist√¢ncias para todos os outros n√≥s alcan√ß√°veis
            soma_distancias = sum(d for d in distancias.values() if d > 0)
            
            if soma_distancias > 0:
                centralidades[usuario] = (n - 1) / soma_distancias
            else:
                centralidades[usuario] = 0
        
        return centralidades
    
    def _bfs_distancias(self, inicio):
        '''Calcula dist√¢ncias usando BFS'''
        distancias = {inicio: 0}
        fila = deque([inicio])
        
        while fila:
            atual = fila.popleft()
            
            for vizinho in self.conexoes[atual]:
                if vizinho not in distancias:
                    distancias[vizinho] = distancias[atual] + 1
                    fila.append(vizinho)
        
        return distancias
    
    def detectar_comunidades_simples(self):
        '''Detecta comunidades usando busca em profundidade'''
        visitados = set()
        comunidades = []
        
        for i in range(len(self.usuarios)):
            if i not in visitados:
                comunidade = self._dfs_comunidade(i, visitados)
                if comunidade:
                    nomes_comunidade = [self.usuarios[idx] for idx in comunidade]
                    comunidades.append(nomes_comunidade)
        
        return comunidades
    
    def _dfs_comunidade(self, inicio, visitados):
        '''DFS para encontrar componente conectado'''
        if inicio in visitados:
            return []
        
        visitados.add(inicio)
        comunidade = [inicio]
        
        for vizinho in self.conexoes[inicio]:
            if vizinho not in visitados:
                comunidade.extend(self._dfs_comunidade(vizinho, visitados))
        
        return comunidade
    
    def calcular_coeficiente_clustering(self, usuario):
        '''Calcula coeficiente de clustering local'''
        if isinstance(usuario, str):
            usuario = self.usuarios.index(usuario)
        
        vizinhos = list(self.conexoes[usuario])
        k = len(vizinhos)
        
        if k < 2:
            return 0.0
        
        # Contar conex√µes entre vizinhos
        conexoes_vizinhos = 0
        for i in range(len(vizinhos)):
            for j in range(i + 1, len(vizinhos)):
                if vizinhos[j] in self.conexoes[vizinhos[i]]:
                    conexoes_vizinhos += 1
        
        # Coeficiente = conex√µes reais / conex√µes poss√≠veis
        conexoes_possiveis = k * (k - 1) // 2
        return conexoes_vizinhos / conexoes_possiveis
    
    def usuarios_mais_influentes(self, n=5):
        '''Encontra os N usu√°rios mais influentes por centralidade de grau'''
        centralidades = self.centralidade_grau()
        ordenados = sorted(centralidades.items(), key=lambda x: x[1], reverse=True)
        return ordenados[:n]
    
    def sugerir_amigos(self, usuario, n=3):
        '''Sugere amigos baseado em amigos em comum'''
        if isinstance(usuario, str):
            usuario_idx = self.usuarios.index(usuario)
        else:
            usuario_idx = usuario
            usuario = self.usuarios[usuario_idx]
        
        amigos_diretos = self.conexoes[usuario_idx]
        sugestoes = defaultdict(int)
        
        # Para cada amigo direto
        for amigo in amigos_diretos:
            # Ver amigos do amigo
            for amigo_do_amigo in self.conexoes[amigo]:
                # Se n√£o √© o pr√≥prio usu√°rio e n√£o √© amigo direto
                if (amigo_do_amigo != usuario_idx and 
                    amigo_do_amigo not in amigos_diretos):
                    sugestoes[amigo_do_amigo] += 1
        
        # Ordenar por n√∫mero de amigos em comum
        melhores = sorted(sugestoes.items(), key=lambda x: x[1], reverse=True)
        
        # Converter √≠ndices para nomes
        resultado = []
        for idx, amigos_comuns in melhores[:n]:
            resultado.append((self.usuarios[idx], amigos_comuns))
        
        return resultado
    
    def estatisticas_rede(self):
        '''Calcula estat√≠sticas gerais da rede'''
        n = len(self.usuarios)
        total_conexoes = sum(len(conexoes) for conexoes in self.conexoes.values()) // 2
        
        # Densidade da rede
        max_conexoes = n * (n - 1) // 2
        densidade = (total_conexoes / max_conexoes) * 100 if max_conexoes > 0 else 0
        
        # Grau m√©dio
        grau_medio = (2 * total_conexoes) / n if n > 0 else 0
        
        # Coeficiente de clustering m√©dio
        clustering_total = 0
        for i in range(n):
            clustering_total += self.calcular_coeficiente_clustering(i)
        clustering_medio = clustering_total / n if n > 0 else 0
        
        return {
            'usuarios': n,
            'conexoes': total_conexoes,
            'densidade': densidade,
            'grau_medio': grau_medio,
            'clustering_medio': clustering_medio
        }

# Exemplo de uso
rede = AnalisadorRedeSocial()

# Construir rede de exemplo
conexoes_exemplo = [
    ('Alice', 'Bob'), ('Alice', 'Carol'), ('Alice', 'David'),
    ('Bob', 'Carol'), ('Bob', 'Eve'),
    ('Carol', 'David'), ('Carol', 'Frank'),
    ('David', 'Frank'),
    ('Eve', 'Grace'), ('Eve', 'Henry'),
    ('Frank', 'Grace'),
    ('Grace', 'Henry'), ('Grace', 'Ivan'),
    ('Henry', 'Ivan')
]

print('üåê AN√ÅLISE DE REDE SOCIAL')
print('=' * 30)

# Adicionar todas as conex√µes
for u1, u2 in conexoes_exemplo:
    rede.adicionar_conexao(u1, u2)

# Construir matriz de adjac√™ncia
rede.construir_matriz_adjacencia()

print(f'Usu√°rios na rede: {rede.usuarios}')
print(f'Total de conex√µes: {len(conexoes_exemplo)}')

# Estat√≠sticas gerais
print('\\nüìä ESTAT√çSTICAS GERAIS:')
stats = rede.estatisticas_rede()
for chave, valor in stats.items():
    if isinstance(valor, float):
        print(f'  {chave.replace(\"_\", \" \").title()}: {valor:.2f}')
    else:
        print(f'  {chave.replace(\"_\", \" \").title()}: {valor}')

# Centralidade de grau
print('\\nüèÜ CENTRALIDADE DE GRAU:')
centralidade_grau = rede.centralidade_grau()
usuarios_ordenados = sorted(centralidade_grau.items(), key=lambda x: x[1], reverse=True)
for usuario, centralidade in usuarios_ordenados[:5]:
    print(f'  {usuario}: {centralidade:.3f}')

# Centralidade de proximidade
print('\\nüìç CENTRALIDADE DE PROXIMIDADE:')
centralidade_prox = rede.centralidade_proximidade()
usuarios_prox = sorted(centralidade_prox.items(), key=lambda x: x[1], reverse=True)
for usuario, centralidade in usuarios_prox[:5]:
    print(f'  {usuario}: {centralidade:.3f}')

# Usu√°rios mais influentes
print('\\n‚≠ê USU√ÅRIOS MAIS INFLUENTES:')
influentes = rede.usuarios_mais_influentes(3)
for i, (usuario, score) in enumerate(influentes, 1):
    print(f'  {i}. {usuario} (Score: {score:.3f})')

# Coeficiente de clustering
print('\\nüîó COEFICIENTE DE CLUSTERING:')
for usuario in rede.usuarios[:5]:
    clustering = rede.calcular_coeficiente_clustering(usuario)
    print(f'  {usuario}: {clustering:.3f}')

# Detec√ß√£o de comunidades
print('\\nüë• COMUNIDADES DETECTADAS:')
comunidades = rede.detectar_comunidades_simples()
for i, comunidade in enumerate(comunidades, 1):
    print(f'  Comunidade {i}: {comunidade}')

# Sugest√µes de amigos
print('\\nüí° SUGEST√ïES DE AMIGOS:')
for usuario in ['Alice', 'Eve']:
    sugestoes = rede.sugerir_amigos(usuario, 2)
    print(f'  Para {usuario}:')
    for amigo_sugerido, amigos_comuns in sugestoes:
        print(f'    {amigo_sugerido} ({amigos_comuns} amigos em comum)')

# An√°lise da matriz esparsa
print('\\nüóúÔ∏è AN√ÅLISE DA MATRIZ ESPARSA:')
matriz_stats = {
    'dimensoes': f'{rede.matriz_adjacencia.linhas}x{rede.matriz_adjacencia.colunas}',
    'elementos_nao_zero': len(rede.matriz_adjacencia.dados),
    'densidade': f'{rede.matriz_adjacencia.densidade():.1f}%',
    'economia_memoria': f'{100 - rede.matriz_adjacencia.densidade():.1f}%'
}

for chave, valor in matriz_stats.items():
    print(f'  {chave.replace(\"_\", \" \").title()}: {valor}')

# Demonstra√ß√£o de algoritmo otimizado vs naive
print('\\n‚ö° COMPARA√á√ÉO DE PERFORMANCE:')
print('(Simula√ß√£o com matriz 100x100)')

# Criar matrizes de teste pequenas para demonstra√ß√£o
import time

def criar_matriz_teste(n, densidade=0.1):
    matriz = [[0 for _ in range(n)] for _ in range(n)]
    import random
    
    elementos_nao_zero = int(n * n * densidade)
    for _ in range(elementos_nao_zero):
        i = random.randint(0, n-1)
        j = random.randint(0, n-1)
        matriz[i][j] = random.randint(1, 10)
    
    return matriz

n_teste = 50
matriz_teste = criar_matriz_teste(n_teste, 0.05)
vetor_teste = [1] * n_teste

# M√©todo denso (naive)
inicio = time.time()
resultado_denso = []
for i in range(n_teste):
    soma = sum(matriz_teste[i][j] * vetor_teste[j] for j in range(n_teste))
    resultado_denso.append(soma)
tempo_denso = time.time() - inicio

# M√©todo esparso (otimizado)
csr_teste = MatrizEsparsaCSR(matriz_teste)
inicio = time.time()
resultado_esparso = csr_teste.multiplicar_vetor(vetor_teste)
tempo_esparso = time.time() - inicio

speedup = tempo_denso / tempo_esparso if tempo_esparso > 0 else float('inf')

print(f'  M√©todo denso: {tempo_denso*1000:.2f}ms')
print(f'  M√©todo esparso: {tempo_esparso*1000:.2f}ms')
print(f'  Speedup: {speedup:.1f}x')
print(f'  Resultados iguais: {resultado_denso == resultado_esparso}')"></textarea>
            
            <button onclick="runCode()" class="btn-run">‚ñ∂Ô∏è Executar C√≥digo</button>
            <div id="output"></div>
        </div>
    </section>

    <section>
        <h2>üíæ Formatos de Matrizes Esparsas</h2>
        
        <table class="sparse-formats-table">
            <tr>
                <th>Formato</th>
                <th>Uso</th>
                <th>Vantagens</th>
                <th>Desvantagens</th>
            </tr>
            <tr>
                <td>COO</td>
                <td>Constru√ß√£o</td>
                <td>Simples, flex√≠vel</td>
                <td>Lento para opera√ß√µes</td>
            </tr>
            <tr>
                <td>CSR</td>
                <td>Multiplica√ß√£o</td>
                <td>R√°pido para Ax</td>
                <td>Dif√≠cil modificar</td>
            </tr>
            <tr>
                <td>CSC</td>
                <td>Opera√ß√µes em colunas</td>
                <td>R√°pido para A^Tx</td>
                <td>Lento para linhas</td>
            </tr>
            <tr>
                <td>DOK</td>
                <td>Constru√ß√£o din√¢mica</td>
                <td>Modifica√ß√£o r√°pida</td>
                <td>Lento para √°lgebra</td>
            </tr>
        </table>
    </section>

    <section>
        <h2>üìà Complexidade e Performance</h2>
        
        <h3>Compara√ß√£o de Opera√ß√µes:</h3>
        <pre><code>def comparar_performance():
    """Compara performance entre representa√ß√µes"""
    
    # Dados de exemplo
    resultados = {
        "Opera√ß√£o": ["Acesso", "Multiplica√ß√£o", "Soma", "Modifica√ß√£o"],
        "Matriz Densa": ["O(1)", "O(n¬≥)", "O(n¬≤)", "O(1)"],
        "Matriz Esparsa": ["O(log nnz)", "O(nnz)", "O(nnz)", "O(log nnz)"],
        "Economia Mem√≥ria": ["0%", "90%+", "90%+", "90%+"]
    }
    
    print("Compara√ß√£o de Performance:")
    print("-" * 60)
    
    for i, operacao in enumerate(resultados["Opera√ß√£o"]):
        print(f"{operacao:12} | {resultados['Matriz Densa'][i]:8} | "
              f"{resultados['Matriz Esparsa'][i]:12} | {resultados['Economia Mem√≥ria'][i]}")
    
    print("-" * 60)
    print("nnz = n√∫mero de elementos n√£o-zero")

comparar_performance()</code></pre>
    </section>

    <section>
        <h2>üîß Bibliotecas Especializadas</h2>
        
        <h3>Usando SciPy (Exemplo Conceitual):</h3>
        <pre><code># Exemplo conceitual - requer scipy
"""
import scipy.sparse as sp
import numpy as np

# Criar matriz esparsa
data = [1, 2, 3, 4]
row = [0, 1, 2, 1]
col = [0, 1, 2, 3]

# Formato COO
coo = sp.coo_matrix((data, (row, col)), shape=(4, 4))

# Converter para CSR para opera√ß√µes eficientes
csr = coo.tocsr()

# Multiplica√ß√£o eficiente
vetor = np.array([1, 1, 1, 1])
resultado = csr.dot(vetor)

# Opera√ß√µes lineares
A = sp.random(1000, 1000, density=0.01)  # 1% de densidade
b = np.random.rand(1000)

# Resolver sistema linear Ax = b
from scipy.sparse.linalg import spsolve
x = spsolve(A, b)
"""

print("Para uso em produ√ß√£o, considere:")
print("- NumPy/SciPy para matrizes esparsas")
print("- BLAS/LAPACK para √°lgebra linear otimizada")
print("- CuPy/CuSparse para GPU")
print("- PETSc para computa√ß√£o paralela")</code></pre>
    </section>

    <section>
        <h2>üí° Estrat√©gias de Otimiza√ß√£o</h2>
        <div class="tip-box">
            <ul>
                <li>üéØ <strong>Escolha o formato certo</strong> - COO para constru√ß√£o, CSR para opera√ß√µes</li>
                <li>üíæ <strong>Minimize realoca√ß√µes</strong> - pr√©-aloque quando poss√≠vel</li>
                <li>‚ö° <strong>Use opera√ß√µes vectorizadas</strong> - evite loops em Python</li>
                <li>üß† <strong>Considere padr√µes de acesso</strong> - row-major vs column-major</li>
                <li>üìä <strong>Profile antes de otimizar</strong> - identifique gargalos reais</li>
                <li>üîß <strong>Use bibliotecas especializadas</strong> - SciPy, NumPy para produ√ß√£o</li>
            </ul>
        </div>
    </section>
{% endblock %}

{% block extra_js %}
<script>
function runCode() {
    const code = document.getElementById('code-input').value;
    const output = document.getElementById('output');
    
    output.innerHTML = '<div class="output-success">Analisador de rede social executado! Veja como matrizes esparsas otimizam an√°lises complexas.</div>';
}
</script>
{% endblock %}