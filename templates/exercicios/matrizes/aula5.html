{% extends "base_aula.html" %}

{% block title %}Aula 5 - Algoritmos com Matrizes | CodeLogic{% endblock %}
{% block lesson_title %}Aula 5 - Algoritmos com Matrizes{% endblock %}

{% block theory_content %}
<div class="content-section">
    <h2>üéØ Objetivos da Aula</h2>
    <ul>
        <li>Implementar algoritmos cl√°ssicos com matrizes</li>
        <li>Trabalhar com rota√ß√£o e reflex√£o</li>
        <li>Aplicar algoritmos de ordena√ß√£o em matrizes</li>
        <li>Resolver problemas complexos</li>
    </ul>
</div>

<div class="content-section">
    <h2>üîÑ Rota√ß√£o de Matriz</h2>
    <p>
        Rotacionar uma matriz √© uma opera√ß√£o comum em gr√°ficos e jogos.
        Vamos implementar rota√ß√£o de 90¬∞ no sentido hor√°rio.
    </p>
    
    <div class="code-example">
        <h3>Rota√ß√£o 90¬∞ Hor√°rio:</h3>
        <pre><code>def rotacionar_90_horario(matriz):
    """Rotaciona matriz 90¬∞ no sentido hor√°rio"""
    n = len(matriz)
    
    # Criar nova matriz
    rotacionada = []
    for i in range(n):
        nova_linha = []
        for j in range(n):
            # Nova posi√ß√£o: linha i vira coluna n-1-i
            nova_linha.append(matriz[n-1-j][i])
        rotacionada.append(nova_linha)
    
    return rotacionada

# Exemplo
original = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

rotacionada = rotacionar_90_horario(original)
print("Original:")
for linha in original:
    print(linha)

print("\nRotacionada 90¬∞:")
for linha in rotacionada:
    print(linha)</code></pre>
    </div>

    <div class="highlight-box">
        <h3>üí° Resultado:</h3>
        <pre>Original:        Rotacionada:
1 2 3      ‚Üí     7 4 1
4 5 6            8 5 2
7 8 9            9 6 3</pre>
    </div>
</div>

<div class="content-section">
    <h2>ü™û Reflex√£o de Matriz</h2>
    
    <div class="code-example">
        <h3>Reflex√£o Horizontal:</h3>
        <pre><code>def reflexao_horizontal(matriz):
    """Espelha matriz horizontalmente"""
    refletida = []
    for linha in matriz:
        linha_refletida = linha[::-1]  # Inverte a linha
        refletida.append(linha_refletida)
    return refletida

# Exemplo
matriz = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

h_refletida = reflexao_horizontal(matriz)
print("Reflex√£o horizontal:")
for linha in h_refletida:
    print(linha)
# [[3, 2, 1], [6, 5, 4], [9, 8, 7]]</code></pre>
    </div>

    <div class="code-example">
        <h3>Reflex√£o Vertical:</h3>
        <pre><code>def reflexao_vertical(matriz):
    """Espelha matriz verticalmente"""
    return matriz[::-1]  # Inverte a ordem das linhas

v_refletida = reflexao_vertical(matriz)
print("Reflex√£o vertical:")
for linha in v_refletida:
    print(linha)
# [[7, 8, 9], [4, 5, 6], [1, 2, 3]]</code></pre>
    </div>
</div>

<div class="content-section">
    <h2>üìä Ordena√ß√£o de Matriz</h2>
    
    <div class="code-example">
        <h3>Ordenar Cada Linha:</h3>
        <pre><code>def ordenar_linhas(matriz):
    """Ordena cada linha da matriz"""
    matriz_ordenada = []
    for linha in matriz:
        linha_ordenada = sorted(linha)
        matriz_ordenada.append(linha_ordenada)
    return matriz_ordenada

matriz_desordenada = [
    [3, 1, 4],
    [9, 2, 6],
    [5, 8, 7]
]

ordenada_linhas = ordenar_linhas(matriz_desordenada)
print("Linhas ordenadas:")
for linha in ordenada_linhas:
    print(linha)</code></pre>
    </div>

    <div class="code-example">
        <h3>Ordenar Cada Coluna:</h3>
        <pre><code>def ordenar_colunas(matriz):
    """Ordena cada coluna da matriz"""
    linhas = len(matriz)
    colunas = len(matriz[0])
    
    # Extrair cada coluna, ordenar e recolocar
    for j in range(colunas):
        coluna = []
        for i in range(linhas):
            coluna.append(matriz[i][j])
        
        coluna_ordenada = sorted(coluna)
        
        for i in range(linhas):
            matriz[i][j] = coluna_ordenada[i]
    
    return matriz

import copy
matriz_copia = copy.deepcopy(matriz_desordenada)
ordenada_colunas = ordenar_colunas(matriz_copia)
print("Colunas ordenadas:")
for linha in ordenada_colunas:
    print(linha)</code></pre>
    </div>

    <div class="code-example">
        <h3>Ordenar Matriz Como Lista:</h3>
        <pre><code>def ordenar_matriz_completa(matriz):
    """Converte matriz em lista, ordena e reconstr√≥i"""
    # Converter para lista √∫nica
    elementos = []
    for linha in matriz:
        elements.extend(linha)
    
    # Ordenar
    elementos.sort()
    
    # Reconstruir matriz
    linhas = len(matriz)
    colunas = len(matriz[0])
    matriz_ordenada = []
    
    for i in range(linhas):
        linha = []
        for j in range(colunas):
            indice = i * colunas + j
            linha.append(elementos[indice])
        matriz_ordenada.append(linha)
    
    return matriz_ordenada

completa_ordenada = ordenar_matriz_completa(matriz_desordenada)
print("Matriz completamente ordenada:")
for linha in completa_ordenada:
    print(linha)</code></pre>
    </div>
</div>

<div class="content-section">
    <h2>üåä Algoritmo de Preenchimento (Flood Fill)</h2>
    
    <div class="code-example">
        <h3>Implementa√ß√£o Recursiva:</h3>
        <pre><code>def flood_fill(matriz, linha, coluna, nova_cor, cor_original=None):
    """Preenche √°rea conectada com nova cor"""
    if cor_original is None:
        cor_original = matriz[linha][coluna]
    
    # Verificar limites
    if (linha < 0 or linha >= len(matriz) or 
        coluna < 0 or coluna >= len(matriz[0])):
        return
    
    # Se n√£o √© a cor original, parar
    if matriz[linha][coluna] != cor_original:
        return
    
    # Se j√° √© a nova cor, parar (evita loop infinito)
    if matriz[linha][coluna] == nova_cor:
        return
    
    # Pintar posi√ß√£o atual
    matriz[linha][coluna] = nova_cor
    
    # Recurs√£o nas 4 dire√ß√µes
    flood_fill(matriz, linha + 1, coluna, nova_cor, cor_original)
    flood_fill(matriz, linha - 1, coluna, nova_cor, cor_original)
    flood_fill(matriz, linha, coluna + 1, nova_cor, cor_original)
    flood_fill(matriz, linha, coluna - 1, nova_cor, cor_original)

# Exemplo: tela de paint
tela = [
    [1, 1, 1, 2, 2],
    [1, 1, 1, 2, 2],
    [1, 1, 1, 2, 2],
    [3, 3, 1, 2, 2],
    [3, 3, 1, 2, 2]
]

print("Tela original:")
for linha in tela:
    print(linha)

# Preencher √°rea conectada de 1 com cor 5, come√ßando em (0,0)
flood_fill(tela, 0, 0, 5)

print("\nAp√≥s flood fill (0,0) com cor 5:")
for linha in tela:
    print(linha)</code></pre>
    </div>
</div>

<div class="content-section">
    <h2>üîç Caminho em Labirinto</h2>
    
    <div class="code-example">
        <h3>Busca de Caminho (DFS):</h3>
        <pre><code>def encontrar_caminho(labirinto, inicio, fim):
    """Encontra caminho em labirinto usando DFS"""
    linhas, colunas = len(labirinto), len(labirinto[0])
    visitado = [[False] * colunas for _ in range(linhas)]
    caminho = []
    
    def dfs(linha, coluna):
        # Verificar limites e se √© parede (1) ou j√° visitado
        if (linha < 0 or linha >= linhas or 
            coluna < 0 or coluna >= colunas or
            labirinto[linha][coluna] == 1 or 
            visitado[linha][coluna]):
            return False
        
        # Marcar como visitado
        visitado[linha][coluna] = True
        caminho.append((linha, coluna))
        
        # Se chegou ao fim
        if (linha, coluna) == fim:
            return True
        
        # Tentar 4 dire√ß√µes
        if (dfs(linha + 1, coluna) or
            dfs(linha - 1, coluna) or
            dfs(linha, coluna + 1) or
            dfs(linha, coluna - 1)):
            return True
        
        # Backtrack
        caminho.pop()
        return False
    
    linha_inicio, coluna_inicio = inicio
    if dfs(linha_inicio, coluna_inicio):
        return caminho
    else:
        return None

# Labirinto: 0 = livre, 1 = parede
labirinto = [
    [0, 1, 0, 0, 0],
    [0, 1, 0, 1, 0],
    [0, 0, 0, 1, 0],
    [1, 1, 0, 0, 0],
    [0, 0, 0, 1, 0]
]

caminho = encontrar_caminho(labirinto, (0, 0), (4, 4))
if caminho:
    print(f"Caminho encontrado: {caminho}")
else:
    print("N√£o h√° caminho")</code></pre>
    </div>
</div>

<div class="content-section">
    <h2>üéÆ Exemplo Pr√°tico: Jogo 2048</h2>
    
    <div class="example-box">
        <h3>Movimento para Esquerda:</h3>
        <pre><code>def mover_esquerda(matriz):
    """Implementa movimento para esquerda do jogo 2048"""
    nova_matriz = []
    
    for linha in matriz:
        # Remover zeros
        nova_linha = [x for x in linha if x != 0]
        
        # Combinar elementos iguais
        i = 0
        while i < len(nova_linha) - 1:
            if nova_linha[i] == nova_linha[i + 1]:
                nova_linha[i] *= 2
                nova_linha.pop(i + 1)
            i += 1
        
        # Preencher com zeros √† direita
        while len(nova_linha) < len(linha):
            nova_linha.append(0)
        
        nova_matriz.append(nova_linha)
    
    return nova_matriz

# Exemplo de tabuleiro 2048
tabuleiro = [
    [2, 2, 4, 8],
    [0, 4, 4, 2],
    [2, 0, 2, 4],
    [0, 0, 0, 2]
]

print("Tabuleiro original:")
for linha in tabuleiro:
    print(linha)

resultado = mover_esquerda(tabuleiro)
print("\nAp√≥s mover esquerda:")
for linha in resultado:
    print(linha)</code></pre>
    </div>
</div>

<div class="content-section">
    <h2>‚ö° Complexidade dos Algoritmos</h2>
    <ul>
        <li><strong>Rota√ß√£o:</strong> O(n¬≤) - precisa visitar cada elemento</li>
        <li><strong>Ordena√ß√£o por linha:</strong> O(n √ó m √ó log m) - n linhas, m elementos por linha</li>
        <li><strong>Flood Fill:</strong> O(n √ó m) - pode visitar cada c√©lula uma vez</li>
        <li><strong>Busca de caminho:</strong> O(n √ó m) - DFS visita cada c√©lula no pior caso</li>
    </ul>
</div>
{% endblock %}

{% block exercise_content %}
<div class="exercise-header">
    <h2>üèãÔ∏è‚Äç‚ôÇÔ∏è Exerc√≠cio Pr√°tico</h2>
    <p>Sistema de Processamento de Imagens</p>
</div>

<div class="exercise-description">
    <h3>üìã Instru√ß√µes:</h3>
    <ol>
        <li>Crie uma "imagem" como matriz 4x4 de valores 0-9</li>
        <li>Implemente fun√ß√£o de rota√ß√£o 90¬∞ hor√°rio</li>
        <li>Implemente fun√ß√£o de reflex√£o horizontal</li>
        <li>Implemente fun√ß√£o para aplicar filtro (somar 1 a cada pixel)</li>
        <li>Implemente fun√ß√£o para detectar bordas (diferen√ßa entre vizinhos)</li>
        <li>Teste todas as transforma√ß√µes</li>
    </ol>
</div>

<div class="exercise-data">
    <h3>üñºÔ∏è Imagem Original:</h3>
    <pre>1 2 3 4
5 6 7 8
9 0 1 2
3 4 5 6</pre>
</div>

<div class="exercise-requirements">
    <h3>üîß Opera√ß√µes Requeridas:</h3>
    <ul>
        <li><strong>Rota√ß√£o:</strong> Rotacionar 90¬∞ no sentido hor√°rio</li>
        <li><strong>Reflex√£o:</strong> Espelhar horizontalmente</li>
        <li><strong>Filtro:</strong> Somar 1 a cada pixel (max 9)</li>
        <li><strong>Bordas:</strong> Calcular diferen√ßa absoluta com vizinhos</li>
    </ul>
</div>

<div class="exercise-hints">
    <h3>üí° Dicas:</h3>
    <ul>
        <li>Para rota√ß√£o: nova_posi√ß√£o[j][n-1-i] = original[i][j]</li>
        <li>Para reflex√£o: inverta a ordem das colunas</li>
        <li>Para filtro: use min(pixel + 1, 9)</li>
        <li>Para bordas: compare cada pixel com seus 4 vizinhos</li>
    </ul>
</div>

<div class="expected-output">
    <h3>üì§ Resultado Esperado:</h3>
    <pre>Imagem Original:
[1, 2, 3, 4]
[5, 6, 7, 8]
[9, 0, 1, 2]
[3, 4, 5, 6]

Rotacionada 90¬∞:
[3, 9, 5, 1]
[4, 0, 6, 2]
[5, 1, 7, 3]
[6, 2, 8, 4]

Refletida Horizontal:
[4, 3, 2, 1]
[8, 7, 6, 5]
[2, 1, 0, 9]
[6, 5, 4, 3]</pre>
</div>
{% endblock %}

{% block starter_code %}
# Exerc√≠cio: Sistema de Processamento de Imagens
# Complete o c√≥digo abaixo

imagem = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 0, 1, 2],
    [3, 4, 5, 6]
]

def rotacionar_90(matriz):
    """Rotaciona matriz 90¬∞ hor√°rio"""
    # Seu c√≥digo aqui
    pass

def reflexao_horizontal(matriz):
    """Espelha matriz horizontalmente"""
    # Seu c√≥digo aqui
    pass

def aplicar_filtro(matriz, incremento=1):
    """Aplica filtro somando incremento (m√°ximo 9)"""
    # Seu c√≥digo aqui
    pass

def detectar_bordas(matriz):
    """Detecta bordas calculando diferen√ßas com vizinhos"""
    # Seu c√≥digo aqui
    pass

def imprimir_matriz(matriz, titulo):
    """Fun√ß√£o auxiliar para imprimir matriz"""
    print(f"\n{titulo}:")
    for linha in matriz:
        print(linha)

# Teste suas fun√ß√µes
print("=== PROCESSAMENTO DE IMAGENS ===")
imprimir_matriz(imagem, "Imagem Original")

# Teste rota√ß√£o
# rotacionada = rotacionar_90(imagem)
# imprimir_matriz(rotacionada, "Rotacionada 90¬∞")

# Teste reflex√£o
# refletida = reflexao_horizontal(imagem)
# imprimir_matriz(refletida, "Refletida Horizontal")

# Teste filtro
# filtrada = aplicar_filtro(imagem)
# imprimir_matriz(filtrada, "Com Filtro (+1)")

# Teste detec√ß√£o de bordas
# bordas = detectar_bordas(imagem)
# imprimir_matriz(bordas, "Detec√ß√£o de Bordas")
{% endblock %}