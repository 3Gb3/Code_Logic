{% extends "base_aula.html" %}

{% block title %}Aula 9 - Decomposi√ß√µes de Matrizes | CodeLogic{% endblock %}

{% block lesson_title %}Aula 9 ‚Äì Decomposi√ß√µes de Matrizes{% endblock %}

{% block lesson_content %}
    <section>
        <h2>üéØ Objetivo</h2>
        <ul>
            <li>Compreender decomposi√ß√µes fundamentais de matrizes</li>
            <li>Implementar decomposi√ß√µes LU, QR e SVD</li>
            <li>Aplicar em resolu√ß√£o de sistemas e an√°lise de dados</li>
        </ul>
    </section>

    <section>
        <h2>üîß Decomposi√ß√£o LU</h2>
        <p>A decomposi√ß√£o LU fatoriza uma matriz A em produto de uma matriz triangular inferior (L) e superior (U).</p>
        
        <div class="formula-box">
            <h3>Decomposi√ß√£o LU:</h3>
            <p><strong>A = L √ó U</strong></p>
            <p>Onde:</p>
            <ul>
                <li>L = matriz triangular inferior (Lower)</li>
                <li>U = matriz triangular superior (Upper)</li>
            </ul>
        </div>
        
        <h3>Implementa√ß√£o da Decomposi√ß√£o LU:</h3>
        <pre><code>def decomposicao_lu(matriz):
    """
    Realiza decomposi√ß√£o LU usando elimina√ß√£o gaussiana
    Retorna L e U tais que A = L √ó U
    """
    n = len(matriz)
    
    # Criar c√≥pias para L e U
    L = [[0.0 for _ in range(n)] for _ in range(n)]
    U = [linha[:] for linha in matriz]  # C√≥pia de A
    
    # Inicializar diagonal de L com 1s
    for i in range(n):
        L[i][i] = 1.0
    
    # Processo de elimina√ß√£o
    for i in range(n):
        # Verificar se elemento piv√¥ √© zero
        if abs(U[i][i]) < 1e-10:
            raise ValueError(f"Elemento piv√¥ muito pequeno na posi√ß√£o ({i},{i})")
        
        # Eliminar elementos abaixo do piv√¥
        for j in range(i + 1, n):
            # Calcular multiplicador
            multiplicador = U[j][i] / U[i][i]
            L[j][i] = multiplicador
            
            # Aplicar elimina√ß√£o na linha j
            for k in range(i, n):
                U[j][k] -= multiplicador * U[i][k]
    
    return L, U

def verificar_decomposicao_lu(A, L, U):
    """Verifica se L √ó U = A"""
    n = len(A)
    produto = [[0.0 for _ in range(n)] for _ in range(n)]
    
    # Calcular L √ó U
    for i in range(n):
        for j in range(n):
            for k in range(n):
                produto[i][j] += L[i][k] * U[k][j]
    
    # Verificar diferen√ßa
    erro_max = 0
    for i in range(n):
        for j in range(n):
            erro = abs(produto[i][j] - A[i][j])
            erro_max = max(erro_max, erro)
    
    return erro_max

def resolver_lu(L, U, b):
    """
    Resolve sistema Ax = b usando decomposi√ß√£o LU
    1. Ly = b (substitui√ß√£o para frente)
    2. Ux = y (substitui√ß√£o para tr√°s)
    """
    n = len(L)
    
    # Passo 1: Resolver Ly = b
    y = [0.0] * n
    for i in range(n):
        y[i] = b[i]
        for j in range(i):
            y[i] -= L[i][j] * y[j]
        y[i] /= L[i][i]
    
    # Passo 2: Resolver Ux = y
    x = [0.0] * n
    for i in range(n - 1, -1, -1):
        x[i] = y[i]
        for j in range(i + 1, n):
            x[i] -= U[i][j] * x[j]
        x[i] /= U[i][i]
    
    return x

# Exemplo pr√°tico
matriz_exemplo = [
    [2, 1, 1],
    [4, 3, 3],
    [8, 7, 9]
]

print("DECOMPOSI√á√ÉO LU")
print("=" * 30)
print("Matriz A:")
for linha in matriz_exemplo:
    print(f"  {linha}")

# Realizar decomposi√ß√£o
L, U = decomposicao_lu(matriz_exemplo)

print("\\nMatriz L (triangular inferior):")
for linha in L:
    print(f"  {[f'{x:6.3f}' for x in linha]}")

print("\\nMatriz U (triangular superior):")
for linha in U:
    print(f"  {[f'{x:6.3f}' for x in linha]}")

# Verificar decomposi√ß√£o
erro = verificar_decomposicao_lu(matriz_exemplo, L, U)
print(f"\\nErro de decomposi√ß√£o: {erro:.2e}")

# Resolver sistema Ax = b
b = [5, 13, 31]
x = resolver_lu(L, U, b)

print(f"\\nSistema: Ax = {b}")
print(f"Solu√ß√£o: x = {[f'{xi:.6f}' for xi in x]}")

# Verificar solu√ß√£o
verificacao = [
    sum(matriz_exemplo[i][j] * x[j] for j in range(len(x)))
    for i in range(len(matriz_exemplo))
]
print(f"Verifica√ß√£o Ax = {[f'{v:.6f}' for v in verificacao]}")</code></pre>
        
        <h3>Decomposi√ß√£o LU com Pivotamento:</h3>
        <pre><code>def decomposicao_lu_pivotamento(matriz):
    """
    Decomposi√ß√£o LU com pivotamento parcial
    Retorna P, L, U tais que PA = LU
    """
    n = len(matriz)
    
    # Inicializar matrizes
    A = [linha[:] for linha in matriz]  # C√≥pia
    L = [[0.0 for _ in range(n)] for _ in range(n)]
    P = [[0.0 for _ in range(n)] for _ in range(n)]
    
    # Inicializar P como identidade
    for i in range(n):
        P[i][i] = 1.0
        L[i][i] = 1.0
    
    # Vetor de permuta√ß√µes
    permutacoes = list(range(n))
    
    for i in range(n):
        # Encontrar piv√¥ (maior elemento em valor absoluto)
        max_linha = i
        for k in range(i + 1, n):
            if abs(A[k][i]) > abs(A[max_linha][i]):
                max_linha = k
        
        # Trocar linhas se necess√°rio
        if max_linha != i:
            A[i], A[max_linha] = A[max_linha], A[i]
            permutacoes[i], permutacoes[max_linha] = permutacoes[max_linha], permutacoes[i]
            
            # Trocar elementos correspondentes em L (apenas abaixo da diagonal)
            for j in range(i):
                L[i][j], L[max_linha][j] = L[max_linha][j], L[i][j]
        
        # Verificar piv√¥
        if abs(A[i][i]) < 1e-10:
            raise ValueError(f"Matriz singular ou quase singular na posi√ß√£o {i}")
        
        # Elimina√ß√£o
        for j in range(i + 1, n):
            multiplicador = A[j][i] / A[i][i]
            L[j][i] = multiplicador
            
            for k in range(i, n):
                A[j][k] -= multiplicador * A[i][k]
    
    # Construir matriz de permuta√ß√£o P
    P_final = [[0.0 for _ in range(n)] for _ in range(n)]
    for i in range(n):
        P_final[i][permutacoes[i]] = 1.0
    
    return P_final, L, A  # A agora √© U

# Teste com matriz que precisa de pivotamento
matriz_pivotamento = [
    [0, 1, 2],
    [1, 2, 1],
    [2, 1, 0]
]

print("\\n" + "="*40)
print("DECOMPOSI√á√ÉO LU COM PIVOTAMENTO")
print("="*40)

P, L_piv, U_piv = decomposicao_lu_pivotamento(matriz_pivotamento)

print("Matriz original:")
for linha in matriz_pivotamento:
    print(f"  {linha}")

print("\\nMatriz de permuta√ß√£o P:")
for linha in P:
    print(f"  {[int(x) for x in linha]}")

print("\\nMatriz L:")
for linha in L_piv:
    print(f"  {[f'{x:6.3f}' for x in linha]}")

print("\\nMatriz U:")
for linha in U_piv:
    print(f"  {[f'{x:6.3f}' for x in linha]}")</code></pre>
    </section>

    <section>
        <h2>üìê Decomposi√ß√£o QR</h2>
        <p>A decomposi√ß√£o QR fatoriza uma matriz A em produto de uma matriz ortogonal (Q) e triangular superior (R).</p>
        
        <h3>Implementa√ß√£o usando Gram-Schmidt:</h3>
        <pre><code>def decomposicao_qr_gram_schmidt(matriz):
    """
    Decomposi√ß√£o QR usando processo de Gram-Schmidt modificado
    Retorna Q (ortogonal) e R (triangular superior) tais que A = QR
    """
    m = len(matriz)      # n√∫mero de linhas
    n = len(matriz[0])   # n√∫mero de colunas
    
    # Inicializar Q e R
    Q = [[0.0 for _ in range(n)] for _ in range(m)]
    R = [[0.0 for _ in range(n)] for _ in range(n)]
    
    # Para cada coluna da matriz
    for j in range(n):
        # Extrair coluna j
        coluna = [matriz[i][j] for i in range(m)]
        
        # Ortogonalizar contra colunas anteriores de Q
        for i in range(j):
            # R[i,j] = produto escalar de Q[:,i] com coluna original
            R[i][j] = sum(Q[k][i] * matriz[k][j] for k in range(m))
            
            # Subtrair proje√ß√£o
            for k in range(m):
                coluna[k] -= R[i][j] * Q[k][i]
        
        # Calcular norma da coluna ortogonalizada
        norma = math.sqrt(sum(x**2 for x in coluna))
        R[j][j] = norma
        
        # Normalizar para obter coluna j de Q
        if norma > 1e-10:
            for i in range(m):
                Q[i][j] = coluna[i] / norma
    
    return Q, R

def verificar_decomposicao_qr(A, Q, R):
    """Verifica se Q √ó R = A"""
    m = len(A)
    n = len(A[0])
    produto = [[0.0 for _ in range(n)] for _ in range(m)]
    
    # Calcular Q √ó R
    for i in range(m):
        for j in range(n):
            for k in range(n):
                produto[i][j] += Q[i][k] * R[k][j]
    
    # Calcular erro m√°ximo
    erro_max = 0
    for i in range(m):
        for j in range(n):
            erro = abs(produto[i][j] - A[i][j])
            erro_max = max(erro_max, erro)
    
    return erro_max

def verificar_ortogonalidade_q(Q):
    """Verifica se Q^T √ó Q = I"""
    m = len(Q)
    n = len(Q[0])
    
    # Calcular Q^T √ó Q
    produto = [[0.0 for _ in range(n)] for _ in range(n)]
    for i in range(n):
        for j in range(n):
            for k in range(m):
                produto[i][j] += Q[k][i] * Q[k][j]
    
    # Verificar se √© aproximadamente identidade
    erro_max = 0
    for i in range(n):
        for j in range(n):
            esperado = 1.0 if i == j else 0.0
            erro = abs(produto[i][j] - esperado)
            erro_max = max(erro_max, erro)
    
    return erro_max

# Exemplo da decomposi√ß√£o QR
matriz_qr = [
    [1, 1, 0],
    [1, 0, 1],
    [0, 1, 1]
]

print("\\n" + "="*30)
print("DECOMPOSI√á√ÉO QR")
print("="*30)

print("Matriz A:")
for linha in matriz_qr:
    print(f"  {linha}")

Q, R = decomposicao_qr_gram_schmidt(matriz_qr)

print("\\nMatriz Q (ortogonal):")
for linha in Q:
    print(f"  {[f'{x:7.4f}' for x in linha]}")

print("\\nMatriz R (triangular superior):")
for linha in R:
    print(f"  {[f'{x:7.4f}' for x in linha]}")

# Verifica√ß√µes
erro_qr = verificar_decomposicao_qr(matriz_qr, Q, R)
erro_ortogonal = verificar_ortogonalidade_q(Q)

print(f"\\nErro QR (||QR - A||): {erro_qr:.2e}")
print(f"Erro ortogonalidade (||Q^TQ - I||): {erro_ortogonal:.2e}")</code></pre>
    </section>

    <section>
        <h2>üåü Decomposi√ß√£o SVD (Singular Value Decomposition)</h2>
        
        <h3>Implementa√ß√£o Simplificada do SVD:</h3>
        <pre><code>def svd_simplificado(matriz, max_iter=1000, tolerancia=1e-10):
    """
    Implementa√ß√£o simplificada do SVD usando m√©todo das pot√™ncias
    Encontra os principais valores singulares e vetores
    """
    A = [linha[:] for linha in matriz]  # C√≥pia
    m = len(A)
    n = len(A[0])
    
    # Calcular A^T √ó A
    AtA = [[0.0 for _ in range(n)] for _ in range(n)]
    for i in range(n):
        for j in range(n):
            for k in range(m):
                AtA[i][j] += A[k][i] * A[k][j]
    
    # Encontrar autovalores de A^T √ó A (s√£o œÉ¬≤)
    valores_singulares = []
    vetores_v = []
    vetores_u = []
    
    # Usar defla√ß√£o para encontrar m√∫ltiplos valores singulares
    matriz_trabalho = [linha[:] for linha in AtA]
    
    rank_estimado = min(m, n, 3)  # Limitar a 3 para demonstra√ß√£o
    
    for i in range(rank_estimado):
        try:
            # Encontrar maior autovalor de A^T A
            autovalor, autovetor = metodo_potencia(matriz_trabalho, max_iter, tolerancia)
            
            if autovalor < tolerancia:
                break
            
            # Valor singular √© a raiz quadrada do autovalor
            valor_singular = math.sqrt(abs(autovalor))
            valores_singulares.append(valor_singular)
            
            # v_i √© o autovetor correspondente
            vetores_v.append(autovetor[:])
            
            # u_i = (1/œÉ_i) √ó A √ó v_i
            Av = [sum(A[j][k] * autovetor[k] for k in range(n)) for j in range(m)]
            norma_Av = math.sqrt(sum(x**2 for x in Av))
            
            if norma_Av > tolerancia:
                u_i = [x / norma_Av for x in Av]
            else:
                u_i = [0.0] * m
            
            vetores_u.append(u_i)
            
            # Defla√ß√£o: remover componente atual
            matriz_trabalho = deflar_matriz_svd(matriz_trabalho, autovalor, autovetor)
            
        except:
            break
    
    return valores_singulares, vetores_u, vetores_v

def deflar_matriz_svd(matriz, autovalor, autovetor):
    """Remove componente principal da matriz"""
    n = len(matriz)
    nova_matriz = [[0.0 for _ in range(n)] for _ in range(n)]
    
    for i in range(n):
        for j in range(n):
            nova_matriz[i][j] = (matriz[i][j] - 
                               autovalor * autovetor[i] * autovetor[j])
    
    return nova_matriz

def reconstruir_matriz_svd(valores_singulares, U, V, k=None):
    """
    Reconstr√≥i matriz usando k primeiros componentes SVD
    A ‚âà Œ£(œÉ_i √ó u_i √ó v_i^T) para i = 1 at√© k
    """
    if k is None:
        k = len(valores_singulares)
    
    m = len(U[0]) if U else 0
    n = len(V[0]) if V else 0
    
    # Inicializar matriz reconstru√≠da
    A_reconstruida = [[0.0 for _ in range(n)] for _ in range(m)]
    
    # Somar contribui√ß√µes de cada componente
    for i in range(min(k, len(valores_singulares))):
        sigma = valores_singulares[i]
        u_i = U[i]
        v_i = V[i]
        
        # Adicionar œÉ_i √ó u_i √ó v_i^T
        for j in range(m):
            for l in range(n):
                A_reconstruida[j][l] += sigma * u_i[j] * v_i[l]
    
    return A_reconstruida

def calcular_erro_reconstrucao(original, reconstruida):
    """Calcula erro de reconstru√ß√£o (norma de Frobenius)"""
    m = len(original)
    n = len(original[0])
    
    erro_total = 0
    for i in range(m):
        for j in range(n):
            diff = original[i][j] - reconstruida[i][j]
            erro_total += diff * diff
    
    return math.sqrt(erro_total)

# Exemplo de aplica√ß√£o do SVD
matriz_svd = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9],
    [10, 11, 12]
]

print("\\n" + "="*40)
print("DECOMPOSI√á√ÉO SVD")
print("="*40)

print("Matriz original A:")
for linha in matriz_svd:
    print(f"  {linha}")

# Executar SVD
valores_s, vetores_u, vetores_v = svd_simplificado(matriz_svd)

print(f"\\nValores singulares: {[f'{s:.4f}' for s in valores_s]}")

print("\\nVetores U (primeiras colunas):")
for i, u in enumerate(vetores_u):
    print(f"  u_{i+1}: {[f'{x:7.4f}' for x in u]}")

print("\\nVetores V (linhas de V^T):")
for i, v in enumerate(vetores_v):
    print(f"  v_{i+1}: {[f'{x:7.4f}' for x in v]}")

# Reconstru√ß√£o com diferentes n√∫meros de componentes
print("\\nRECONSTRU√á√ÉO COM DIFERENTES N√öMEROS DE COMPONENTES:")
for k in range(1, min(4, len(valores_s) + 1)):
    reconstruida = reconstruir_matriz_svd(valores_s, vetores_u, vetores_v, k)
    erro = calcular_erro_reconstrucao(matriz_svd, reconstruida)
    
    print(f"\\nCom {k} componente(s) - Erro: {erro:.4f}")
    for linha in reconstruida:
        print(f"  {[f'{x:7.2f}' for x in linha]}")</code></pre>
    </section>

    <section>
        <h2>üéÆ Exerc√≠cio Pr√°tico</h2>
        <div class="exercise-box">
            <h3>Sistema de Compress√£o de Imagens com SVD</h3>
            <p>Implemente um sistema que simula compress√£o de imagens usando decomposi√ß√£o SVD:</p>
            <ul>
                <li>Simula√ß√£o de dados de imagem como matriz</li>
                <li>Aplica√ß√£o de SVD para compress√£o</li>
                <li>An√°lise de qualidade vs taxa de compress√£o</li>
            </ul>
            
            <textarea id="code-input" placeholder="import math
import random

class CompressorImagemSVD:
    '''Simulador de compress√£o de imagens usando SVD'''
    
    def __init__(self):
        self.imagem_original = None
        self.valores_singulares = []
        self.vetores_u = []
        self.vetores_v = []
        self.dimensoes = (0, 0)
    
    def gerar_imagem_exemplo(self, altura=8, largura=8, tipo='gradiente'):
        '''Gera imagem de exemplo para demonstra√ß√£o'''
        self.dimensoes = (altura, largura)
        
        if tipo == 'gradiente':
            # Gradiente diagonal
            self.imagem_original = []
            for i in range(altura):
                linha = []
                for j in range(largura):
                    # Valor baseado na dist√¢ncia do canto
                    valor = 255 * (i + j) / (altura + largura - 2)
                    linha.append(int(valor))
                self.imagem_original.append(linha)
        
        elif tipo == 'xadrez':
            # Padr√£o xadrez
            tamanho_quadrado = 2
            self.imagem_original = []
            for i in range(altura):
                linha = []
                for j in range(largura):
                    quad_i = i // tamanho_quadrado
                    quad_j = j // tamanho_quadrado
                    if (quad_i + quad_j) % 2 == 0:
                        linha.append(255)
                    else:
                        linha.append(0)
                self.imagem_original.append(linha)
        
        elif tipo == 'circulo':
            # C√≠rculo no centro
            centro_x, centro_y = altura // 2, largura // 2
            raio = min(altura, largura) // 3
            
            self.imagem_original = []
            for i in range(altura):
                linha = []
                for j in range(largura):
                    distancia = math.sqrt((i - centro_x)**2 + (j - centro_y)**2)
                    if distancia <= raio:
                        linha.append(255)
                    else:
                        # Gradiente suave fora do c√≠rculo
                        valor = max(0, 255 - int(20 * (distancia - raio)))
                        linha.append(valor)
                self.imagem_original.append(linha)
        
        elif tipo == 'ruido':
            # Imagem com ru√≠do estruturado
            self.imagem_original = []
            for i in range(altura):
                linha = []
                for j in range(largura):
                    # Padr√£o base mais ru√≠do
                    base = 128 + 50 * math.sin(i * 0.5) * math.cos(j * 0.5)
                    ruido = random.randint(-30, 30)
                    valor = max(0, min(255, int(base + ruido)))
                    linha.append(valor)
                self.imagem_original.append(linha)
        
        return self.imagem_original
    
    def aplicar_svd(self):
        '''Aplica decomposi√ß√£o SVD na imagem'''
        if not self.imagem_original:
            raise ValueError('Nenhuma imagem carregada')
        
        print('üîç Aplicando SVD na imagem...')
        
        # Converter para formato float para c√°lculos
        matriz_float = [[float(pixel) for pixel in linha] 
                       for linha in self.imagem_original]
        
        # Aplicar SVD
        self.valores_singulares, self.vetores_u, self.vetores_v = svd_simplificado(matriz_float)
        
        print(f'‚úì SVD conclu√≠do: {len(self.valores_singulares)} componentes principais encontrados')
        
        return len(self.valores_singulares)
    
    def comprimir_imagem(self, num_componentes):
        '''Comprime imagem usando apenas num_componentes principais'''
        if not self.valores_singulares:
            raise ValueError('SVD n√£o foi aplicado ainda')
        
        # Reconstruir usando apenas k componentes
        imagem_comprimida = reconstruir_matriz_svd(
            self.valores_singulares, 
            self.vetores_u, 
            self.vetores_v, 
            num_componentes
        )
        
        # Converter de volta para inteiros e clipar valores
        resultado = []
        for linha in imagem_comprimida:
            linha_int = []
            for pixel in linha:
                valor = max(0, min(255, round(pixel)))
                linha_int.append(int(valor))
            resultado.append(linha_int)
        
        return resultado
    
    def calcular_metricas_compressao(self, imagem_comprimida):
        '''Calcula m√©tricas de qualidade da compress√£o'''
        altura, largura = self.dimensoes
        
        # Erro quadr√°tico m√©dio (MSE)
        mse = 0
        for i in range(altura):
            for j in range(largura):
                diff = self.imagem_original[i][j] - imagem_comprimida[i][j]
                mse += diff * diff
        
        mse /= (altura * largura)
        
        # PSNR (Peak Signal-to-Noise Ratio)
        if mse > 0:
            psnr = 20 * math.log10(255 / math.sqrt(mse))
        else:
            psnr = float('inf')
        
        # Taxa de compress√£o
        # Original: altura * largura valores
        # Comprimido: num_componentes * (altura + largura + 1)
        tamanho_original = altura * largura
        num_comp = len([s for s in self.valores_singulares if s > 1e-6])
        tamanho_comprimido = num_comp * (altura + largura + 1)
        taxa_compressao = tamanho_original / tamanho_comprimido
        
        return {
            'mse': mse,
            'psnr': psnr,
            'taxa_compressao': taxa_compressao,
            'num_componentes': num_comp
        }
    
    def exibir_imagem_ascii(self, imagem, titulo=''):
        '''Exibe imagem usando caracteres ASCII'''
        if titulo:
            print(f'\\n{titulo}:')
        
        # Escala de cinza em ASCII (do mais escuro ao mais claro)
        escala = ' .:-=+*#%@'
        
        for linha in imagem:
            linha_ascii = ''
            for pixel in linha:
                # Mapear valor 0-255 para √≠ndice da escala
                indice = min(len(escala) - 1, pixel * len(escala) // 256)
                linha_ascii += escala[indice] * 2  # 2x para melhor propor√ß√£o
            print(linha_ascii)
    
    def analisar_componentes_principais(self):
        '''Analisa a import√¢ncia dos componentes principais'''
        if not self.valores_singulares:
            return
        
        print('\\nüìä AN√ÅLISE DOS COMPONENTES PRINCIPAIS:')
        print('=' * 45)
        
        # Calcular energia total
        energia_total = sum(s**2 for s in self.valores_singulares)
        
        energia_acumulada = 0
        for i, sigma in enumerate(self.valores_singulares):
            energia_comp = sigma**2
            energia_acumulada += energia_comp
            
            porcentagem_individual = (energia_comp / energia_total) * 100
            porcentagem_acumulada = (energia_acumulada / energia_total) * 100
            
            print(f'Componente {i+1:2d}: œÉ={sigma:8.3f}, '
                  f'Energia={porcentagem_individual:5.1f}%, '
                  f'Acum={porcentagem_acumulada:5.1f}%')
        
        # Encontrar quantos componentes para 90% e 95% da energia
        energia_parcial = 0
        for i, sigma in enumerate(self.valores_singulares):
            energia_parcial += sigma**2
            porcentagem = (energia_parcial / energia_total) * 100
            
            if porcentagem >= 90 and i < len(self.valores_singulares) - 1:
                print(f'\\nüí° {i+1} componentes capturam 90% da energia')
                break
        
        for i, sigma in enumerate(self.valores_singulares):
            energia_parcial_95 = sum(s**2 for s in self.valores_singulares[:i+1])
            porcentagem_95 = (energia_parcial_95 / energia_total) * 100
            
            if porcentagem_95 >= 95:
                print(f'üí° {i+1} componentes capturam 95% da energia')
                break
    
    def demonstracao_completa(self, tipo_imagem='gradiente'):
        '''Executa demonstra√ß√£o completa do sistema'''
        print('üñºÔ∏è  SISTEMA DE COMPRESS√ÉO DE IMAGENS COM SVD')
        print('=' * 50)
        
        # Gerar imagem de exemplo
        print(f'Gerando imagem de exemplo (tipo: {tipo_imagem})...')
        self.gerar_imagem_exemplo(8, 8, tipo_imagem)
        
        # Exibir imagem original
        self.exibir_imagem_ascii(self.imagem_original, 'IMAGEM ORIGINAL')
        
        # Aplicar SVD
        num_componentes = self.aplicar_svd()
        
        # Analisar componentes
        self.analisar_componentes_principais()
        
        # Testar diferentes n√≠veis de compress√£o
        print('\\nüóúÔ∏è  TESTANDO DIFERENTES N√çVEIS DE COMPRESS√ÉO:')
        print('=' * 50)
        
        niveis_teste = [1, 2, 3, min(4, num_componentes)]
        
        for k in niveis_teste:
            if k <= num_componentes:
                print(f'\\n--- COMPRESS√ÉO COM {k} COMPONENTE(S) ---')
                
                # Comprimir
                img_comprimida = self.comprimir_imagem(k)
                
                # Calcular m√©tricas
                metricas = self.calcular_metricas_compressao(img_comprimida)
                
                print(f'MSE: {metricas[\"mse\"]:.2f}')
                print(f'PSNR: {metricas[\"psnr\"]:.2f} dB')
                print(f'Taxa de compress√£o: {metricas[\"taxa_compressao\"]:.1f}:1')
                
                # Exibir resultado
                self.exibir_imagem_ascii(img_comprimida, f'COMPRIMIDA ({k} comp.)')
        
        return True

# Demonstra√ß√£o com diferentes tipos de imagens
tipos_imagem = ['gradiente', 'xadrez', 'circulo', 'ruido']

for tipo in tipos_imagem:
    print('\\n' + '='*60)
    print(f'DEMONSTRA√á√ÉO: IMAGEM TIPO {tipo.upper()}')
    print('='*60)
    
    compressor = CompressorImagemSVD()
    compressor.demonstracao_completa(tipo)
    
    # An√°lise espec√≠fica para cada tipo
    print(f'\\nüìà AN√ÅLISE ESPEC√çFICA - {tipo.upper()}:')
    if tipo == 'gradiente':
        print('- Gradientes s√£o bem comprimidos pelo SVD')
        print('- Poucos componentes capturam a estrutura linear')
    elif tipo == 'xadrez':
        print('- Padr√µes regulares requerem mais componentes')
        print('- Bordas n√≠tidas s√£o desafiadoras para SVD')
    elif tipo == 'circulo':
        print('- Formas geom√©tricas t√™m compress√£o moderada')
        print('- Gradientes suaves s√£o bem representados')
    elif tipo == 'ruido':
        print('- Ru√≠do dificulta compress√£o eficiente')
        print('- Muitos componentes necess√°rios para qualidade')

print('\\nüéØ CONCLUS√ïES GERAIS:')
print('='*30)
print('1. SVD √© eficaz para imagens com estrutura suave')
print('2. Imagens com ru√≠do ou detalhes finos precisam mais componentes')
print('3. Trade-off entre qualidade e taxa de compress√£o')
print('4. PSNR > 30dB geralmente indica qualidade aceit√°vel')
print('5. Primeiros componentes capturam estruturas principais')

# Exemplo de compara√ß√£o direta
print('\\nüîç COMPARA√á√ÉO DIRETA: GRADIENTE vs RU√çDO')
print('='*45)

# Gradiente simples
comp1 = CompressorImagemSVD()
comp1.gerar_imagem_exemplo(6, 6, 'gradiente')
comp1.aplicar_svd()
img1_comp = comp1.comprimir_imagem(2)
metricas1 = comp1.calcular_metricas_compressao(img1_comp)

# Ru√≠do
comp2 = CompressorImagemSVD()
comp2.gerar_imagem_exemplo(6, 6, 'ruido')
comp2.aplicar_svd()
img2_comp = comp2.comprimir_imagem(2)
metricas2 = comp2.calcular_metricas_compressao(img2_comp)

print(f'Gradiente (2 comp.): PSNR = {metricas1[\"psnr\"]:.1f} dB')
print(f'Ru√≠do (2 comp.):     PSNR = {metricas2[\"psnr\"]:.1f} dB')
print(f'Diferen√ßa de qualidade: {metricas1[\"psnr\"] - metricas2[\"psnr\"]:.1f} dB')"></textarea>
            
            <button onclick="runCode()" class="btn-run">‚ñ∂Ô∏è Executar C√≥digo</button>
            <div id="output"></div>
        </div>
    </section>

    <section>
        <h2>üìä Compara√ß√£o de Decomposi√ß√µes</h2>
        
        <table class="decomposition-table">
            <tr>
                <th>Decomposi√ß√£o</th>
                <th>Formato</th>
                <th>Aplica√ß√£o Principal</th>
                <th>Complexidade</th>
            </tr>
            <tr>
                <td>LU</td>
                <td>A = LU</td>
                <td>Sistemas lineares</td>
                <td>O(n¬≥)</td>
            </tr>
            <tr>
                <td>QR</td>
                <td>A = QR</td>
                <td>M√≠nimos quadrados</td>
                <td>O(mn¬≤)</td>
            </tr>
            <tr>
                <td>SVD</td>
                <td>A = UŒ£V^T</td>
                <td>Redu√ß√£o dimensionalidade</td>
                <td>O(min(m¬≤n, mn¬≤))</td>
            </tr>
            <tr>
                <td>Cholesky</td>
                <td>A = LL^T</td>
                <td>Matrizes positivas definidas</td>
                <td>O(n¬≥/3)</td>
            </tr>
        </table>
    </section>

    <section>
        <h2>üîß Aplica√ß√µes Pr√°ticas</h2>
        
        <div class="applications-grid">
            <div class="app-card">
                <h3>üíª Computa√ß√£o Cient√≠fica</h3>
                <ul>
                    <li>Resolu√ß√£o de sistemas lineares</li>
                    <li>Interpola√ß√£o e ajuste de curvas</li>
                    <li>Simula√ß√µes num√©ricas</li>
                </ul>
            </div>
            
            <div class="app-card">
                <h3>üìä An√°lise de Dados</h3>
                <ul>
                    <li>Redu√ß√£o de dimensionalidade</li>
                    <li>Filtragem de ru√≠do</li>
                    <li>Compress√£o de dados</li>
                </ul>
            </div>
            
            <div class="app-card">
                <h3>üé® Processamento de Imagens</h3>
                <ul>
                    <li>Compress√£o JPEG</li>
                    <li>Denoising</li>
                    <li>Reconhecimento de padr√µes</li>
                </ul>
            </div>
            
            <div class="app-card">
                <h3>ü§ñ Machine Learning</h3>
                <ul>
                    <li>PCA para feature extraction</li>
                    <li>Sistemas de recomenda√ß√£o</li>
                    <li>An√°lise de sentimentos</li>
                </ul>
            </div>
        </div>
    </section>

    <section>
        <h2>‚ö° Otimiza√ß√µes Num√©ricas</h2>
        
        <h3>Estabilidade Num√©rica:</h3>
        <pre><code>def verificar_condicao_matriz(matriz):
    """Estima n√∫mero de condi√ß√£o da matriz"""
    # Usar SVD para estimar condi√ß√£o
    valores_s, _, _ = svd_simplificado(matriz)
    
    if len(valores_s) > 0 and valores_s[-1] > 1e-15:
        condicao = valores_s[0] / valores_s[-1]
    else:
        condicao = float('inf')
    
    return condicao

def escolher_decomposicao(matriz, aplicacao='geral'):
    """Sugere melhor decomposi√ß√£o baseada na matriz e aplica√ß√£o"""
    m = len(matriz)
    n = len(matriz[0])
    
    # Verificar se √© quadrada
    quadrada = (m == n)
    
    # Estimar condi√ß√£o
    condicao = verificar_condicao_matriz(matriz)
    
    sugestoes = []
    
    if aplicacao == 'sistema_linear' and quadrada:
        if condicao < 1e12:
            sugestoes.append("LU com pivotamento")
        else:
            sugestoes.append("SVD (mais est√°vel)")
    
    elif aplicacao == 'minimos_quadrados':
        sugestoes.append("QR (m√©todo preferido)")
        if condicao > 1e12:
            sugestoes.append("SVD (para casos mal-condicionados)")
    
    elif aplicacao == 'pca' or aplicacao == 'compressao':
        sugestoes.append("SVD (ideal para an√°lise espectral)")
    
    else:
        if quadrada and condicao < 1e8:
            sugestoes.append("LU")
        sugestoes.append("QR (vers√°til)")
        sugestoes.append("SVD (mais informativo)")
    
    return {
        'condicao': condicao,
        'quadrada': quadrada,
        'sugestoes': sugestoes
    }

# Teste de sele√ß√£o de m√©todo
matrizes_teste = {
    'bem_condicionada': [[2, 1], [1, 2]],
    'mal_condicionada': [[1, 1], [1, 1.0001]],
    'retangular': [[1, 2, 3], [4, 5, 6]]
}

print("\\n" + "="*50)
print("SELE√á√ÉO AUTOM√ÅTICA DE DECOMPOSI√á√ÉO")
print("="*50)

for nome, matriz in matrizes_teste.items():
    print(f"\\nMatriz {nome}:")
    analise = escolher_decomposicao(matriz, 'sistema_linear')
    
    print(f"  Condi√ß√£o: {analise['condicao']:.2e}")
    print(f"  Quadrada: {analise['quadrada']}")
    print("  Sugest√µes:")
    for sugestao in analise['sugestoes']:
        print(f"    - {sugestao}")</code></pre>
    </section>

    <section>
        <h2>üí° Considera√ß√µes de Implementa√ß√£o</h2>
        <div class="tip-box">
            <ul>
                <li>üéØ <strong>Escolha baseada no problema</strong> - LU para sistemas, QR para m√≠nimos quadrados, SVD para an√°lise</li>
                <li>üî¢ <strong>Pivotamento essencial</strong> - sempre use pivotamento em LU para estabilidade</li>
                <li>‚öñÔ∏è <strong>Trade-off precis√£o-performance</strong> - SVD √© mais lento mas mais informativo</li>
                <li>üß† <strong>Monitore condi√ß√£o</strong> - matrizes mal-condicionadas precisam m√©todos especiais</li>
                <li>üíæ <strong>Reutilize decomposi√ß√µes</strong> - calcule uma vez, use m√∫ltiplas vezes</li>
                <li>üîß <strong>Use bibliotecas otimizadas</strong> - LAPACK/BLAS para produ√ß√£o</li>
            </ul>
        </div>
    </section>
{% endblock %}

{% block extra_js %}
<script>
function runCode() {
    const code = document.getElementById('code-input').value;
    const output = document.getElementById('output');
    
    output.innerHTML = '<div class="output-success">Compressor de imagens SVD executado! Veja como decomposi√ß√µes de matrizes permitem compress√£o eficiente mantendo qualidade.</div>';
}
</script>
{% endblock %}