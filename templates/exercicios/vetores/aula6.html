{% extends "base_aula.html" %}

{% block title %}Aula 6 - Listas Aninhadas | CodeLogic{% endblock %}

{% block lesson_title %}Aula 6 ‚Äì Listas Aninhadas{% endblock %}

{% block lesson_content %}
    <section>
        <h2>üéØ Objetivo</h2>
        <ul>
            <li>Trabalhar com listas dentro de listas (matrizes)</li>
            <li>Navegar e manipular estruturas bidimensionais</li>
            <li>Implementar algoritmos para listas aninhadas</li>
        </ul>
    </section>

    <section>
        <h2>üìã Conceito de Listas Aninhadas</h2>
        <p>Listas aninhadas s√£o listas que cont√™m outras listas como elementos, criando estruturas bidimensionais ou multidimensionais.</p>
        
        <h3>Cria√ß√£o de Listas Aninhadas:</h3>
        <pre><code># Cria√ß√£o manual
matriz = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

# Usando list comprehension
matriz_zeros = [[0 for j in range(3)] for i in range(3)]
print(f"Matriz 3x3 de zeros: {matriz_zeros}")

# ‚ùå CUIDADO: N√£o fa√ßa isso!
matriz_errada = [[0] * 3] * 3  # Todas as linhas referenciam a mesma lista!

# ‚úÖ CORRETO: Cada linha √© uma lista separada
matriz_correta = [[0] * 3 for _ in range(3)]

# Demonstrar o problema
matriz_errada[0][0] = 1
print(f"Matriz errada: {matriz_errada}")  # Todas as linhas mudam!

matriz_correta[0][0] = 1
print(f"Matriz correta: {matriz_correta}")  # Apenas primeira linha muda</code></pre>
        
        <h3>Listas Irregulares (Jagged Arrays):</h3>
        <pre><code># Listas com tamanhos diferentes
triangulo = [
    [1],
    [1, 1],
    [1, 2, 1],
    [1, 3, 3, 1],
    [1, 4, 6, 4, 1]
]

# Calend√°rio mensal
calendario = [
    ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "S√°b"],
    [None, None, 1, 2, 3, 4, 5],
    [6, 7, 8, 9, 10, 11, 12],
    [13, 14, 15, 16, 17, 18, 19],
    [20, 21, 22, 23, 24, 25, 26],
    [27, 28, 29, 30, 31, None, None]
]

print("Tri√¢ngulo de Pascal:")
for linha in triangulo:
    print(linha)</code></pre>
    </section>

    <section>
        <h2>üîç Acessando Elementos</h2>
        
        <h3>Indexa√ß√£o Bidimensional:</h3>
        <pre><code>matriz = [
    [10, 20, 30],
    [40, 50, 60],
    [70, 80, 90]
]

# Acessar elemento espec√≠fico - matriz[linha][coluna]
print(f"Elemento [1][2]: {matriz[1][2]}")  # 60
print(f"Primeira linha: {matriz[0]}")      # [10, 20, 30]
print(f"√öltima linha: {matriz[-1]}")       # [70, 80, 90]

# Acessar coluna (requer loop ou compreens√£o)
primeira_coluna = [linha[0] for linha in matriz]
print(f"Primeira coluna: {primeira_coluna}")  # [10, 40, 70]

# Acessar diagonal principal
diagonal = [matriz[i][i] for i in range(len(matriz))]
print(f"Diagonal principal: {diagonal}")  # [10, 50, 90]</code></pre>
        
        <h3>Slicing em Listas Aninhadas:</h3>
        <pre><code>dados = [
    [1, 2, 3, 4, 5],
    [6, 7, 8, 9, 10],
    [11, 12, 13, 14, 15],
    [16, 17, 18, 19, 20]
]

# Slice de linhas
primeiras_duas_linhas = dados[:2]
print(f"Primeiras 2 linhas: {primeiras_duas_linhas}")

# Slice de colunas em cada linha
primeiras_tres_colunas = [linha[:3] for linha in dados]
print(f"Primeiras 3 colunas: {primeiras_tres_colunas}")

# Submatriz
submatriz = [linha[1:4] for linha in dados[1:3]]
print(f"Submatriz [1:3][1:4]: {submatriz}")  # [[7, 8, 9], [12, 13, 14]]</code></pre>
    </section>

    <section>
        <h2>üîÑ Itera√ß√£o em Listas Aninhadas</h2>
        
        <h3>Loops Aninhados:</h3>
        <pre><code>notas = [
    [8.5, 7.0, 9.0],
    [6.5, 8.0, 7.5],
    [9.0, 9.5, 8.5]
]

# Iterar por todos os elementos
print("Todas as notas:")
for i in range(len(notas)):
    for j in range(len(notas[i])):
        print(f"Aluno {i+1}, Prova {j+1}: {notas[i][j]}")

# Iterar usando enumerate
print("\nUsando enumerate:")
for i, linha in enumerate(notas):
    for j, nota in enumerate(linha):
        print(f"Aluno {i+1}, Prova {j+1}: {nota}")

# Iterar apenas pelos valores
print("\nApenas valores:")
for linha in notas:
    for nota in linha:
        print(f"Nota: {nota}")</code></pre>
        
        <h3>List Comprehensions Aninhadas:</h3>
        <pre><code># Achatar lista aninhada
matriz = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
achatada = [elemento for linha in matriz for elemento in linha]
print(f"Lista achatada: {achatada}")  # [1, 2, 3, 4, 5, 6, 7, 8, 9]

# Aplicar opera√ß√£o a todos os elementos
matriz_quadrada = [[x**2 for x in linha] for linha in matriz]
print(f"Elementos ao quadrado: {matriz_quadrada}")

# Filtrar elementos
pares_matriz = [[x for x in linha if x % 2 == 0] for linha in matriz]
print(f"Apenas pares: {pares_matriz}")

# Transpor matriz
transposta = [[linha[i] for linha in matriz] for i in range(len(matriz[0]))]
print(f"Matriz transposta: {transposta}")</code></pre>
    </section>

    <section>
        <h2>üõ†Ô∏è Opera√ß√µes com Matrizes</h2>
        
        <h3>Opera√ß√µes B√°sicas:</h3>
        <pre><code>def criar_matriz(linhas, colunas, valor_inicial=0):
    """Cria matriz com dimens√µes espec√≠ficas"""
    return [[valor_inicial for j in range(colunas)] for i in range(linhas)]

def dimensoes_matriz(matriz):
    """Retorna dimens√µes da matriz"""
    if not matriz:
        return 0, 0
    return len(matriz), len(matriz[0])

def imprimir_matriz(matriz, titulo="Matriz"):
    """Imprime matriz formatada"""
    print(f"\n{titulo}:")
    for linha in matriz:
        print("  ", end="")
        for elemento in linha:
            print(f"{elemento:4}", end=" ")
        print()

# Testes
matriz_3x4 = criar_matriz(3, 4, 5)
linhas, colunas = dimensoes_matriz(matriz_3x4)
print(f"Dimens√µes: {linhas}x{colunas}")
imprimir_matriz(matriz_3x4, "Matriz 3x4 com valor 5")</code></pre>
        
        <h3>Somar Matrizes:</h3>
        <pre><code>def somar_matrizes(matriz1, matriz2):
    """Soma duas matrizes de mesma dimens√£o"""
    # Verificar dimens√µes
    if len(matriz1) != len(matriz2) or len(matriz1[0]) != len(matriz2[0]):
        raise ValueError("Matrizes devem ter mesmas dimens√µes")
    
    resultado = []
    for i in range(len(matriz1)):
        linha_resultado = []
        for j in range(len(matriz1[0])):
            linha_resultado.append(matriz1[i][j] + matriz2[i][j])
        resultado.append(linha_resultado)
    
    return resultado

# Com list comprehension
def somar_matrizes_comp(m1, m2):
    return [[m1[i][j] + m2[i][j] for j in range(len(m1[0]))] 
            for i in range(len(m1))]

# Teste
A = [[1, 2], [3, 4]]
B = [[5, 6], [7, 8]]
soma = somar_matrizes(A, B)
print(f"A + B = {soma}")  # [[6, 8], [10, 12]]</code></pre>
        
        <h3>Multiplicar Matrizes:</h3>
        <pre><code>def multiplicar_matrizes(matriz1, matriz2):
    """Multiplica duas matrizes"""
    # Verificar se multiplica√ß√£o √© poss√≠vel
    if len(matriz1[0]) != len(matriz2):
        raise ValueError("N√∫mero de colunas de A deve ser igual ao n√∫mero de linhas de B")
    
    linhas_a = len(matriz1)
    colunas_a = len(matriz1[0])
    colunas_b = len(matriz2[0])
    
    # Criar matriz resultado
    resultado = [[0 for j in range(colunas_b)] for i in range(linhas_a)]
    
    # Calcular produto
    for i in range(linhas_a):
        for j in range(colunas_b):
            for k in range(colunas_a):
                resultado[i][j] += matriz1[i][k] * matriz2[k][j]
    
    return resultado

# Teste
A = [[1, 2], [3, 4]]
B = [[5, 6], [7, 8]]
produto = multiplicar_matrizes(A, B)
print(f"A √ó B = {produto}")  # [[19, 22], [43, 50]]</code></pre>
    </section>

    <section>
        <h2>üéÆ Exerc√≠cio Pr√°tico</h2>
        <div class="exercise-box">
            <h3>Jogo da Velha (Tic-Tac-Toe)</h3>
            <p>Implemente um jogo da velha usando listas aninhadas para representar o tabuleiro:</p>
            <ul>
                <li>Tabuleiro 3x3 representado por lista aninhada</li>
                <li>Verifica√ß√£o de vit√≥ria em linhas, colunas e diagonais</li>
                <li>Valida√ß√£o de jogadas e controle de turnos</li>
            </ul>
            
            <textarea id="code-input" placeholder="class JogoDaVelha:
    def __init__(self):
        # Tabuleiro 3x3 vazio (None = posi√ß√£o vazia)
        self.tabuleiro = [[None for j in range(3)] for i in range(3)]
        self.jogador_atual = 'X'
        self.jogo_acabou = False
        self.vencedor = None
    
    def imprimir_tabuleiro(self):
        '''Exibe o tabuleiro formatado'''
        print('\n  0   1   2')
        for i in range(3):
            linha = f'{i} '
            for j in range(3):
                simbolo = self.tabuleiro[i][j] if self.tabuleiro[i][j] else ' '
                linha += f'{simbolo}'
                if j < 2:
                    linha += ' | '
            print(linha)
            if i < 2:
                print('  ---------')
    
    def posicao_valida(self, linha, coluna):
        '''Verifica se a posi√ß√£o √© v√°lida e est√° vazia'''
        if linha < 0 or linha > 2 or coluna < 0 or coluna > 2:
            return False, 'Posi√ß√£o fora do tabuleiro!'
        
        if self.tabuleiro[linha][coluna] is not None:
            return False, 'Posi√ß√£o j√° ocupada!'
        
        return True, 'Posi√ß√£o v√°lida'
    
    def fazer_jogada(self, linha, coluna):
        '''Executa uma jogada'''
        if self.jogo_acabou:
            return False, 'Jogo j√° terminou!'
        
        valida, mensagem = self.posicao_valida(linha, coluna)
        if not valida:
            return False, mensagem
        
        # Fazer a jogada
        self.tabuleiro[linha][coluna] = self.jogador_atual
        
        # Verificar vit√≥ria
        if self.verificar_vitoria():
            self.jogo_acabou = True
            self.vencedor = self.jogador_atual
            return True, f'Jogador {self.jogador_atual} venceu!'
        
        # Verificar empate
        if self.tabuleiro_cheio():
            self.jogo_acabou = True
            return True, 'Empate!'
        
        # Trocar jogador
        self.jogador_atual = 'O' if self.jogador_atual == 'X' else 'X'
        return True, f'Vez do jogador {self.jogador_atual}'
    
    def verificar_linha(self, linha):
        '''Verifica se h√° vit√≥ria na linha'''
        return (self.tabuleiro[linha][0] == self.tabuleiro[linha][1] == 
                self.tabuleiro[linha][2] != None)
    
    def verificar_coluna(self, coluna):
        '''Verifica se h√° vit√≥ria na coluna'''
        return (self.tabuleiro[0][coluna] == self.tabuleiro[1][coluna] == 
                self.tabuleiro[2][coluna] != None)
    
    def verificar_diagonal_principal(self):
        '''Verifica diagonal principal (\\\\)'''
        return (self.tabuleiro[0][0] == self.tabuleiro[1][1] == 
                self.tabuleiro[2][2] != None)
    
    def verificar_diagonal_secundaria(self):
        '''Verifica diagonal secund√°ria (/)'''
        return (self.tabuleiro[0][2] == self.tabuleiro[1][1] == 
                self.tabuleiro[2][0] != None)
    
    def verificar_vitoria(self):
        '''Verifica todas as condi√ß√µes de vit√≥ria'''
        # Verificar linhas
        for i in range(3):
            if self.verificar_linha(i):
                return True
        
        # Verificar colunas
        for j in range(3):
            if self.verificar_coluna(j):
                return True
        
        # Verificar diagonais
        if self.verificar_diagonal_principal() or self.verificar_diagonal_secundaria():
            return True
        
        return False
    
    def tabuleiro_cheio(self):
        '''Verifica se o tabuleiro est√° completamente preenchido'''
        for linha in self.tabuleiro:
            if None in linha:
                return False
        return True
    
    def reiniciar_jogo(self):
        '''Reinicia o jogo'''
        self.tabuleiro = [[None for j in range(3)] for i in range(3)]
        self.jogador_atual = 'X'
        self.jogo_acabou = False
        self.vencedor = None
    
    def obter_posicoes_vazias(self):
        '''Retorna lista de posi√ß√µes vazias'''
        posicoes = []
        for i in range(3):
            for j in range(3):
                if self.tabuleiro[i][j] is None:
                    posicoes.append((i, j))
        return posicoes

# Simulando um jogo
jogo = JogoDaVelha()

print('üéÆ JOGO DA VELHA')
print('=' * 20)

# Sequ√™ncia de jogadas para demonstra√ß√£o
jogadas = [
    (1, 1),  # X no centro
    (0, 0),  # O no canto
    (0, 1),  # X na borda
    (2, 1),  # O na borda
    (2, 2),  # X no canto
    (0, 2),  # O no canto - vit√≥ria!
]

for i, (linha, coluna) in enumerate(jogadas):
    print(f'\\nJogada {i+1}: Jogador {jogo.jogador_atual} joga em ({linha}, {coluna})')
    
    sucesso, mensagem = jogo.fazer_jogada(linha, coluna)
    print(f'Resultado: {mensagem}')
    
    jogo.imprimir_tabuleiro()
    
    if jogo.jogo_acabou:
        if jogo.vencedor:
            print(f'\\nüèÜ Parab√©ns! Jogador {jogo.vencedor} venceu!')
        else:
            print(f'\\nü§ù Jogo empatou!')
        break

# Mostrar an√°lise do tabuleiro
print(f'\\nüìä AN√ÅLISE FINAL:')
print(f'Posi√ß√µes vazias: {jogo.obter_posicoes_vazias()}')
print(f'Tabuleiro cheio: {jogo.tabuleiro_cheio()}')
print(f'Jogo acabou: {jogo.jogo_acabou}')

# Demonstrar matriz de vit√≥rias poss√≠veis
print(f'\\nüéØ PADR√ïES DE VIT√ìRIA:')
print('Linhas:', [[jogo.verificar_linha(i)] for i in range(3)])
print('Colunas:', [[jogo.verificar_coluna(j)] for j in range(3)])
print('Diagonais:', [jogo.verificar_diagonal_principal(), jogo.verificar_diagonal_secundaria()])"></textarea>
            
            <button onclick="runCode()" class="btn-run">‚ñ∂Ô∏è Executar C√≥digo</button>
            <div id="output"></div>
        </div>
    </section>

    <section>
        <h2>üß© Algoritmos para Listas Aninhadas</h2>
        
        <h3>Busca em Matriz:</h3>
        <pre><code>def buscar_elemento_matriz(matriz, elemento):
    """Busca elemento em matriz e retorna todas as posi√ß√µes"""
    posicoes = []
    
    for i in range(len(matriz)):
        for j in range(len(matriz[i])):
            if matriz[i][j] == elemento:
                posicoes.append((i, j))
    
    return posicoes

def buscar_em_matriz_ordenada(matriz, elemento):
    """Busca em matriz onde cada linha est√° ordenada"""
    for i in range(len(matriz)):
        # Busca bin√°ria em cada linha
        linha = matriz[i]
        esquerda, direita = 0, len(linha) - 1
        
        while esquerda <= direita:
            meio = (esquerda + direita) // 2
            if linha[meio] == elemento:
                return (i, meio)
            elif linha[meio] < elemento:
                esquerda = meio + 1
            else:
                direita = meio - 1
    
    return None

# Teste
matriz = [[1, 2, 3], [4, 2, 6], [7, 8, 2]]
posicoes = buscar_elemento_matriz(matriz, 2)
print(f"Elemento 2 encontrado em: {posicoes}")  # [(0, 1), (1, 1), (2, 2)]</code></pre>
        
        <h3>Rota√ß√£o de Matriz:</h3>
        <pre><code>def rotacionar_90_graus(matriz):
    """Rotaciona matriz 90 graus no sentido hor√°rio"""
    linhas = len(matriz)
    colunas = len(matriz[0])
    
    # Nova matriz com dimens√µes trocadas
    resultado = [[0 for j in range(linhas)] for i in range(colunas)]
    
    for i in range(linhas):
        for j in range(colunas):
            resultado[j][linhas - 1 - i] = matriz[i][j]
    
    return resultado

def espelhar_horizontal(matriz):
    """Espelha matriz horizontalmente"""
    return [linha[::-1] for linha in matriz]

def espelhar_vertical(matriz):
    """Espelha matriz verticalmente"""
    return matriz[::-1]

# Teste
original = [[1, 2, 3], [4, 5, 6]]
rotacionada = rotacionar_90_graus(original)
print(f"Original: {original}")
print(f"Rotacionada 90¬∞: {rotacionada}")  # [[4, 1], [5, 2], [6, 3]]</code></pre>
    </section>

    <section>
        <h2>üìä An√°lise de Dados com Listas Aninhadas</h2>
        
        <h3>Opera√ß√µes Estat√≠sticas:</h3>
        <pre><code>def estatisticas_matriz(matriz):
    """Calcula estat√≠sticas da matriz"""
    # Achatar matriz
    todos_valores = [elemento for linha in matriz for elemento in linha]
    
    return {
        'soma': sum(todos_valores),
        'media': sum(todos_valores) / len(todos_valores),
        'maximo': max(todos_valores),
        'minimo': min(todos_valores),
        'total_elementos': len(todos_valores)
    }

def soma_por_linha(matriz):
    """Soma elementos de cada linha"""
    return [sum(linha) for linha in matriz]

def soma_por_coluna(matriz):
    """Soma elementos de cada coluna"""
    if not matriz:
        return []
    
    num_colunas = len(matriz[0])
    return [sum(linha[j] for linha in matriz) for j in range(num_colunas)]

# Teste
vendas = [
    [100, 150, 200],  # Janeiro
    [120, 180, 250],  # Fevereiro
    [90, 160, 220]    # Mar√ßo
]

print("Vendas por m√™s:")
stats = estatisticas_matriz(vendas)
print(f"Estat√≠sticas: {stats}")

print(f"Total por m√™s: {soma_por_linha(vendas)}")
print(f"Total por produto: {soma_por_coluna(vendas)}")</code></pre>
    </section>

    <section>
        <h2>üí° Boas Pr√°ticas</h2>
        <div class="tip-box">
            <ul>
                <li>‚úÖ Use list comprehension para criar listas aninhadas</li>
                <li>‚ùå Evite [[0]*n]*m - cria refer√™ncias duplicadas</li>
                <li>üîç Sempre verifique dimens√µes antes de opera√ß√µes</li>
                <li>üìä Use enumerate() para acessar √≠ndices e valores</li>
                <li>üéØ Considere NumPy para opera√ß√µes matem√°ticas complexas</li>
                <li>üß† Pense em performance para matrizes grandes</li>
            </ul>
        </div>
    </section>

    <section>
        <h2>üîß Padr√µes √öteis</h2>
        
        <h3>Percorrer Vizinhos (8 dire√ß√µes):</h3>
        <pre><code>def obter_vizinhos(matriz, linha, coluna):
    """Obt√©m todos os vizinhos v√°lidos de uma posi√ß√£o"""
    linhas = len(matriz)
    colunas = len(matriz[0])
    
    # 8 dire√ß√µes: cima, baixo, esquerda, direita e diagonais
    direcoes = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]
    
    vizinhos = []
    for dl, dc in direcoes:
        nova_linha = linha + dl
        nova_coluna = coluna + dc
        
        # Verificar se est√° dentro dos limites
        if 0 <= nova_linha < linhas and 0 <= nova_coluna < colunas:
            vizinhos.append((nova_linha, nova_coluna, matriz[nova_linha][nova_coluna]))
    
    return vizinhos

# Teste
grade = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
vizinhos_centro = obter_vizinhos(grade, 1, 1)
print(f"Vizinhos do centro (5): {vizinhos_centro}")</code></pre>
    </section>
{% endblock %}

{% block extra_js %}
<script>
function runCode() {
    const code = document.getElementById('code-input').value;
    const output = document.getElementById('output');
    
    output.innerHTML = '<div class="output-success">Jogo da Velha executado! Veja como listas aninhadas podem representar estruturas bidimensionais.</div>';
}
</script>
{% endblock %}