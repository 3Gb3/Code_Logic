{% extends "base_aula.html" %}

{% block title %}Aula 7 - Tuplas | CodeLogic{% endblock %}

{% block lesson_title %}Aula 7 â€“ Tuplas{% endblock %}

{% block lesson_content %}
    <section>
        <h2>ğŸ¯ Objetivo</h2>
        <ul>
            <li>Compreender o conceito e caracterÃ­sticas das tuplas</li>
            <li>Trabalhar com estruturas de dados imutÃ¡veis</li>
            <li>Aplicar tuplas em situaÃ§Ãµes prÃ¡ticas</li>
        </ul>
    </section>

    <section>
        <h2>ğŸ“¦ O que sÃ£o Tuplas?</h2>
        <p>Tuplas sÃ£o estruturas de dados <strong>imutÃ¡veis</strong> que armazenam uma coleÃ§Ã£o ordenada de elementos. Uma vez criadas, nÃ£o podem ser modificadas.</p>
        
        <h3>CaracterÃ­sticas das Tuplas:</h3>
        <ul>
            <li>ğŸ”’ <strong>ImutÃ¡veis</strong> - nÃ£o podem ser alteradas apÃ³s criaÃ§Ã£o</li>
            <li>ğŸ“‹ <strong>Ordenadas</strong> - mantÃªm a ordem dos elementos</li>
            <li>ğŸ”¢ <strong>Indexadas</strong> - acesso por Ã­ndice como listas</li>
            <li>ğŸ”„ <strong>Permitem duplicatas</strong> - podem ter elementos repetidos</li>
            <li>âš¡ <strong>Mais rÃ¡pidas</strong> que listas para acesso</li>
        </ul>
        
        <h3>CriaÃ§Ã£o de Tuplas:</h3>
        <pre><code># Tupla vazia
tupla_vazia = ()
print(f"Tupla vazia: {tupla_vazia}")
print(f"Tipo: {type(tupla_vazia)}")

# Tupla com elementos
cores = ("vermelho", "verde", "azul")
numeros = (1, 2, 3, 4, 5)
mista = ("Python", 3.9, True, 42)

# Tupla de um elemento (cuidado com a vÃ­rgula!)
um_elemento = (42,)  # VÃ­rgula necessÃ¡ria
nao_tupla = (42)     # Isso Ã© apenas um int com parÃªnteses!

print(f"Um elemento: {um_elemento}, tipo: {type(um_elemento)}")
print(f"NÃ£o Ã© tupla: {nao_tupla}, tipo: {type(nao_tupla)}")

# CriaÃ§Ã£o sem parÃªnteses
coordenadas = 10, 20
print(f"Coordenadas: {coordenadas}, tipo: {type(coordenadas)}")

# Usando tuple()
lista = [1, 2, 3]
tupla_da_lista = tuple(lista)
print(f"De lista para tupla: {tupla_da_lista}")</code></pre>
    </section>

    <section>
        <h2>ğŸ” Acessando Elementos</h2>
        
        <h3>IndexaÃ§Ã£o e Slicing:</h3>
        <pre><code>frutas = ("maÃ§Ã£", "banana", "uva", "pÃªra", "manga")

# IndexaÃ§Ã£o positiva
print(f"Primeira fruta: {frutas[0]}")    # maÃ§Ã£
print(f"Terceira fruta: {frutas[2]}")    # uva

# IndexaÃ§Ã£o negativa
print(f"Ãšltima fruta: {frutas[-1]}")     # manga
print(f"PenÃºltima: {frutas[-2]}")        # pÃªra

# Slicing
print(f"Primeiras 3: {frutas[:3]}")      # ('maÃ§Ã£', 'banana', 'uva')
print(f"Ãšltimas 2: {frutas[-2:]}")       # ('pÃªra', 'manga')
print(f"Do meio: {frutas[1:4]}")         # ('banana', 'uva', 'pÃªra')

# Desempacotamento (unpacking)
x, y, z = (10, 20, 30)
print(f"x={x}, y={y}, z={z}")

# Desempacotamento com asterisco
primeiro, *meio, ultimo = frutas
print(f"Primeiro: {primeiro}")
print(f"Meio: {meio}")
print(f"Ãšltimo: {ultimo}")</code></pre>
        
        <h3>IteraÃ§Ã£o em Tuplas:</h3>
        <pre><code>notas = (8.5, 7.2, 9.0, 6.8, 8.9)

# IteraÃ§Ã£o simples
print("Todas as notas:")
for nota in notas:
    print(f"  {nota}")

# Com enumerate
print("Notas com Ã­ndice:")
for i, nota in enumerate(notas):
    print(f"  Nota {i+1}: {nota}")

# Verificar se elemento existe
if 9.0 in notas:
    print("Nota 9.0 encontrada!")

# Contar elementos
print(f"PosiÃ§Ãµes da nota 8.5: {notas.count(8.5)}")
print(f"Primeira posiÃ§Ã£o da nota 9.0: {notas.index(9.0)}")</code></pre>
    </section>

    <section>
        <h2>ğŸ› ï¸ MÃ©todos de Tuplas</h2>
        <p>Tuplas tÃªm apenas dois mÃ©todos, pois sÃ£o imutÃ¡veis:</p>
        
        <h3>count() e index():</h3>
        <pre><code>numeros = (1, 2, 3, 2, 4, 2, 5)

# count() - conta ocorrÃªncias
contador_2 = numeros.count(2)
print(f"NÃºmero 2 aparece {contador_2} vezes")  # 3

contador_6 = numeros.count(6)
print(f"NÃºmero 6 aparece {contador_6} vezes")  # 0

# index() - encontra primeira posiÃ§Ã£o
posicao = numeros.index(3)
print(f"NÃºmero 3 estÃ¡ na posiÃ§Ã£o {posicao}")   # 2

primeira_pos_2 = numeros.index(2)
print(f"Primeira posiÃ§Ã£o do 2: {primeira_pos_2}")  # 1

# index() com slice
try:
    pos_2_apos_3 = numeros.index(2, 3)  # Buscar 2 a partir da posiÃ§Ã£o 3
    print(f"PrÃ³ximo 2 apÃ³s posiÃ§Ã£o 3: {pos_2_apos_3}")  # 3
except ValueError:
    print("Elemento nÃ£o encontrado")</code></pre>
    </section>

    <section>
        <h2>ğŸ”„ OperaÃ§Ãµes com Tuplas</h2>
        
        <h3>ConcatenaÃ§Ã£o e RepetiÃ§Ã£o:</h3>
        <pre><code># ConcatenaÃ§Ã£o
tupla1 = (1, 2, 3)
tupla2 = (4, 5, 6)
concatenada = tupla1 + tupla2
print(f"Concatenada: {concatenada}")  # (1, 2, 3, 4, 5, 6)

# RepetiÃ§Ã£o
repetida = (0, 1) * 3
print(f"Repetida: {repetida}")  # (0, 1, 0, 1, 0, 1)

# ComparaÃ§Ã£o
print(f"(1, 2) < (1, 3): {(1, 2) < (1, 3)}")    # True
print(f"(1, 2) == (1, 2): {(1, 2) == (1, 2)}")  # True

# Tamanho
coordenadas = (10, 20, 30)
print(f"Tamanho: {len(coordenadas)}")  # 3</code></pre>
        
        <h3>Convertendo Entre Tipos:</h3>
        <pre><code># Lista para tupla
lista = [1, 2, 3, 4, 5]
tupla = tuple(lista)
print(f"Lista â†’ Tupla: {tupla}")

# Tupla para lista
volta_lista = list(tupla)
print(f"Tupla â†’ Lista: {volta_lista}")

# String para tupla
palavra = "Python"
letras = tuple(palavra)
print(f"String â†’ Tupla: {letras}")  # ('P', 'y', 't', 'h', 'o', 'n')

# Range para tupla
numeros = tuple(range(5))
print(f"Range â†’ Tupla: {numeros}")  # (0, 1, 2, 3, 4)</code></pre>
    </section>

    <section>
        <h2>ğŸ® ExercÃ­cio PrÃ¡tico</h2>
        <div class="exercise-box">
            <h3>Sistema de Coordenadas e Pontos</h3>
            <p>Crie um sistema para trabalhar com pontos em um plano cartesiano usando tuplas:</p>
            <ul>
                <li>Representar pontos como tuplas (x, y)</li>
                <li>Calcular distÃ¢ncias entre pontos</li>
                <li>Verificar se pontos formam figuras geomÃ©tricas</li>
            </ul>
            
            <textarea id="code-input" placeholder="import math

class SistemaCoordenadas:
    @staticmethod
    def criar_ponto(x, y):
        '''Cria um ponto como tupla'''
        return (x, y)
    
    @staticmethod
    def distancia_euclidiana(ponto1, ponto2):
        '''Calcula distÃ¢ncia euclidiana entre dois pontos'''
        x1, y1 = ponto1
        x2, y2 = ponto2
        return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)
    
    @staticmethod
    def distancia_manhattan(ponto1, ponto2):
        '''Calcula distÃ¢ncia de Manhattan (soma das diferenÃ§as absolutas)'''
        x1, y1 = ponto1
        x2, y2 = ponto2
        return abs(x2 - x1) + abs(y2 - y1)
    
    @staticmethod
    def ponto_medio(ponto1, ponto2):
        '''Calcula ponto mÃ©dio entre dois pontos'''
        x1, y1 = ponto1
        x2, y2 = ponto2
        return ((x1 + x2) / 2, (y1 + y2) / 2)
    
    @staticmethod
    def quadrante(ponto):
        '''Determina o quadrante do ponto'''
        x, y = ponto
        
        if x > 0 and y > 0:
            return 1
        elif x < 0 and y > 0:
            return 2
        elif x < 0 and y < 0:
            return 3
        elif x > 0 and y < 0:
            return 4
        elif x == 0 and y != 0:
            return 'Eixo Y'
        elif y == 0 and x != 0:
            return 'Eixo X'
        else:
            return 'Origem'
    
    @staticmethod
    def eh_triangulo(ponto1, ponto2, ponto3):
        '''Verifica se trÃªs pontos formam um triÃ¢ngulo'''
        # Calcula as distÃ¢ncias entre os pontos
        d1 = SistemaCoordenadas.distancia_euclidiana(ponto1, ponto2)
        d2 = SistemaCoordenadas.distancia_euclidiana(ponto2, ponto3)
        d3 = SistemaCoordenadas.distancia_euclidiana(ponto3, ponto1)
        
        # Verifica a desigualdade triangular
        return (d1 + d2 > d3) and (d2 + d3 > d1) and (d3 + d1 > d2)
    
    @staticmethod
    def eh_retangulo(ponto1, ponto2, ponto3, ponto4):
        '''Verifica se quatro pontos formam um retÃ¢ngulo'''
        pontos = [ponto1, ponto2, ponto3, ponto4]
        
        # Calcula todas as distÃ¢ncias possÃ­veis
        distancias = []
        for i in range(4):
            for j in range(i+1, 4):
                dist = SistemaCoordenadas.distancia_euclidiana(pontos[i], pontos[j])
                distancias.append(round(dist, 6))  # Arredondar para evitar erros de float
        
        # Ordena as distÃ¢ncias
        distancias.sort()
        
        # Em um retÃ¢ngulo: 4 lados iguais dois a dois + 2 diagonais iguais
        # EntÃ£o devemos ter: [lado1, lado1, lado2, lado2, diagonal, diagonal]
        return (distancias[0] == distancias[1] and 
                distancias[2] == distancias[3] and 
                distancias[4] == distancias[5])
    
    @staticmethod
    def area_triangulo(ponto1, ponto2, ponto3):
        '''Calcula Ã¡rea do triÃ¢ngulo formado por trÃªs pontos'''
        x1, y1 = ponto1
        x2, y2 = ponto2
        x3, y3 = ponto3
        
        # FÃ³rmula: |x1(y2-y3) + x2(y3-y1) + x3(y1-y2)| / 2
        area = abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)) / 2
        return area
    
    @staticmethod
    def ordenar_por_distancia_origem(pontos):
        '''Ordena pontos por distÃ¢ncia da origem'''
        origem = (0, 0)
        return sorted(pontos, key=lambda p: SistemaCoordenadas.distancia_euclidiana(p, origem))

# Testando o sistema
sistema = SistemaCoordenadas()

print('ğŸ“ SISTEMA DE COORDENADAS')
print('=' * 30)

# Criando pontos
pontos = [
    sistema.criar_ponto(3, 4),
    sistema.criar_ponto(-2, 1),
    sistema.criar_ponto(0, -3),
    sistema.criar_ponto(5, 0),
    sistema.criar_ponto(-1, -2)
]

print('\\nğŸ“‹ PONTOS CRIADOS:')
for i, ponto in enumerate(pontos):
    x, y = ponto
    quadrante = sistema.quadrante(ponto)
    print(f'  P{i+1}: ({x}, {y}) - Quadrante: {quadrante}')

# Calculando distÃ¢ncias
print('\\nğŸ“ DISTÃ‚NCIAS:')
p1, p2 = pontos[0], pontos[1]
dist_euclidiana = sistema.distancia_euclidiana(p1, p2)
dist_manhattan = sistema.distancia_manhattan(p1, p2)
ponto_medio = sistema.ponto_medio(p1, p2)

print(f'Entre {p1} e {p2}:')
print(f'  Euclidiana: {dist_euclidiana:.2f}')
print(f'  Manhattan: {dist_manhattan:.2f}')
print(f'  Ponto mÃ©dio: ({ponto_medio[0]:.1f}, {ponto_medio[1]:.1f})')

# Verificando formas geomÃ©tricas
print('\\nğŸ”º ANÃLISE DE TRIÃ‚NGULO:')
triangulo = pontos[:3]
eh_triangulo = sistema.eh_triangulo(*triangulo)
if eh_triangulo:
    area = sistema.area_triangulo(*triangulo)
    print(f'Pontos {triangulo} formam um triÃ¢ngulo')
    print(f'Ãrea do triÃ¢ngulo: {area:.2f}')
else:
    print(f'Pontos {triangulo} NÃƒO formam um triÃ¢ngulo')

# Verificando retÃ¢ngulo
print('\\nâ¬œ ANÃLISE DE RETÃ‚NGULO:')
retangulo_pontos = [(0, 0), (0, 3), (4, 3), (4, 0)]
eh_retangulo = sistema.eh_retangulo(*retangulo_pontos)
print(f'Pontos {retangulo_pontos}')
print(f'Formam retÃ¢ngulo: {\"SIM\" if eh_retangulo else \"NÃƒO\"}')

# Ordenando por distÃ¢ncia da origem
print('\\nğŸ¯ ORDENAÃ‡ÃƒO POR DISTÃ‚NCIA DA ORIGEM:')
ordenados = sistema.ordenar_por_distancia_origem(pontos)
origem = (0, 0)

for i, ponto in enumerate(ordenados):
    dist = sistema.distancia_euclidiana(ponto, origem)
    print(f'  {i+1}Âº: {ponto} - DistÃ¢ncia: {dist:.2f}')

# Demonstrando imutabilidade das tuplas
print('\\nğŸ”’ DEMONSTRAÃ‡ÃƒO DE IMUTABILIDADE:')
ponto_original = (10, 20)
print(f'Ponto original: {ponto_original}')

# NÃ£o podemos fazer: ponto_original[0] = 15  # Isso daria erro!
# Em vez disso, criamos um novo ponto
ponto_modificado = (15, ponto_original[1])
print(f'Novo ponto: {ponto_modificado}')
print(f'Ponto original permanece: {ponto_original}')

# Tuplas aninhadas
print('\\nğŸ—ï¸ ESTRUTURAS COMPLEXAS COM TUPLAS:')
linha_pontos = ((0, 0), (1, 1), (2, 2), (3, 3))
print(f'Linha diagonal: {linha_pontos}')

# Desempacotamento de mÃºltiplos pontos
x_coords, y_coords = zip(*linha_pontos)
print(f'Coordenadas X: {x_coords}')
print(f'Coordenadas Y: {y_coords}')"></textarea>
            
            <button onclick="runCode()" class="btn-run">â–¶ï¸ Executar CÃ³digo</button>
            <div id="output"></div>
        </div>
    </section>

    <section>
        <h2>ğŸ†š Tuplas vs Listas</h2>
        
        <table class="comparison-table">
            <tr>
                <th>Aspecto</th>
                <th>Tuplas</th>
                <th>Listas</th>
            </tr>
            <tr>
                <td>Mutabilidade</td>
                <td>âŒ ImutÃ¡vel</td>
                <td>âœ… MutÃ¡vel</td>
            </tr>
            <tr>
                <td>Performance</td>
                <td>âš¡ Mais rÃ¡pida</td>
                <td>ğŸŒ Mais lenta</td>
            </tr>
            <tr>
                <td>Uso de MemÃ³ria</td>
                <td>ğŸ’¾ Menor</td>
                <td>ğŸ’¾ Maior</td>
            </tr>
            <tr>
                <td>MÃ©todos</td>
                <td>ğŸ“¦ 2 (count, index)</td>
                <td>ğŸ› ï¸ Muitos</td>
            </tr>
            <tr>
                <td>Uso como Chave</td>
                <td>ğŸ—ï¸ Pode ser chave de dict</td>
                <td>âŒ NÃ£o pode</td>
            </tr>
            <tr>
                <td>Quando Usar</td>
                <td>ğŸ“‹ Dados que nÃ£o mudam</td>
                <td>ğŸ“ Dados que mudam</td>
            </tr>
        </table>
    </section>

    <section>
        <h2>ğŸ¯ Casos de Uso das Tuplas</h2>
        
        <h3>1. Coordenadas e Pontos:</h3>
        <pre><code># Representar coordenadas
ponto_2d = (10, 20)
ponto_3d = (10, 20, 30)
cor_rgb = (255, 128, 0)

# Lista de coordenadas
pontos = [(0, 0), (1, 1), (2, 4), (3, 9)]</code></pre>
        
        <h3>2. Retorno de MÃºltiplos Valores:</h3>
        <pre><code>def dividir_com_resto(dividendo, divisor):
    """Retorna quociente e resto"""
    return dividendo // divisor, dividendo % divisor

def estatisticas(numeros):
    """Retorna min, max, mÃ©dia"""
    return min(numeros), max(numeros), sum(numeros)/len(numeros)

# Uso
quociente, resto = dividir_com_resto(17, 5)
minimo, maximo, media = estatisticas([1, 2, 3, 4, 5])</code></pre>
        
        <h3>3. ConfiguraÃ§Ãµes e Constantes:</h3>
        <pre><code># ConfiguraÃ§Ãµes que nÃ£o devem mudar
RESOLUCOES = (
    (1920, 1080),
    (1366, 768),
    (1024, 768)
)

# Dados de pessoa (registro)
pessoa = ("JoÃ£o", "Silva", 30, "Engenheiro")
nome, sobrenome, idade, profissao = pessoa</code></pre>
        
        <h3>4. Chaves de DicionÃ¡rio:</h3>
        <pre><code># Usando tuplas como chaves
temperaturas = {
    (2023, 1, 15): 25.5,    # (ano, mÃªs, dia): temperatura
    (2023, 1, 16): 26.0,
    (2023, 1, 17): 24.8
}

# Matriz esparsa
matriz_esparsa = {
    (0, 0): 1,
    (1, 2): 5,
    (3, 1): 9
}</code></pre>
    </section>

    <section>
        <h2>ğŸ§© Named Tuples</h2>
        <p>Para tuplas com campos nomeados, use <code>namedtuple</code>:</p>
        
        <pre><code>from collections import namedtuple

# Definir estrutura
Pessoa = namedtuple('Pessoa', ['nome', 'idade', 'cidade'])

# Criar instÃ¢ncias
joao = Pessoa('JoÃ£o', 30, 'SÃ£o Paulo')
maria = Pessoa('Maria', 25, 'Rio de Janeiro')

# Acessar por nome ou Ã­ndice
print(f"Nome: {joao.nome}")        # JoÃ£o
print(f"Idade: {joao[1]}")         # 30

# MÃ©todos Ãºteis
print(f"Campos: {joao._fields}")   # ('nome', 'idade', 'cidade')
print(f"Como dict: {joao._asdict()}")

# Criar nova instÃ¢ncia com alteraÃ§Ã£o
joao_mais_velho = joao._replace(idade=31)
print(f"JoÃ£o mais velho: {joao_mais_velho}")

# Ponto 2D com mÃ©todos
Ponto = namedtuple('Ponto', ['x', 'y'])

def distancia(p1, p2):
    return ((p1.x - p2.x)**2 + (p1.y - p2.y)**2)**0.5

p1 = Ponto(0, 0)
p2 = Ponto(3, 4)
print(f"DistÃ¢ncia: {distancia(p1, p2)}")  # 5.0</code></pre>
    </section>

    <section>
        <h2>âš¡ Performance e OtimizaÃ§Ã£o</h2>
        
        <h3>ComparaÃ§Ã£o de Performance:</h3>
        <pre><code>import time

# Teste de criaÃ§Ã£o
def teste_criacao():
    start = time.time()
    
    # Tuplas
    for i in range(1000000):
        t = (1, 2, 3, 4, 5)
    
    tempo_tupla = time.time() - start
    
    start = time.time()
    
    # Listas
    for i in range(1000000):
        l = [1, 2, 3, 4, 5]
    
    tempo_lista = time.time() - start
    
    print(f"CriaÃ§Ã£o - Tupla: {tempo_tupla:.4f}s")
    print(f"CriaÃ§Ã£o - Lista: {tempo_lista:.4f}s")
    print(f"Tupla Ã© {tempo_lista/tempo_tupla:.2f}x mais rÃ¡pida")

# Teste de acesso
def teste_acesso():
    tupla = tuple(range(1000))
    lista = list(range(1000))
    
    start = time.time()
    for i in range(100000):
        x = tupla[500]
    tempo_tupla = time.time() - start
    
    start = time.time()
    for i in range(100000):
        x = lista[500]
    tempo_lista = time.time() - start
    
    print(f"Acesso - Tupla: {tempo_tupla:.4f}s")
    print(f"Acesso - Lista: {tempo_lista:.4f}s")</code></pre>
    </section>

    <section>
        <h2>ğŸ’¡ Dicas Importantes</h2>
        <div class="tip-box">
            <ul>
                <li>ğŸ”’ Use tuplas para dados que nÃ£o devem mudar</li>
                <li>âš¡ Tuplas sÃ£o mais rÃ¡pidas que listas para acesso</li>
                <li>ğŸ—ï¸ Tuplas podem ser chaves de dicionÃ¡rio</li>
                <li>ğŸ“¦ VÃ­rgula Ã© crucial para tuplas de um elemento: (42,)</li>
                <li>ğŸ¯ Use desempacotamento para mÃºltiplos retornos</li>
                <li>ğŸ“‹ Named tuples para estruturas mais legÃ­veis</li>
                <li>ğŸ” Use tuplas para coordenadas e pontos</li>
            </ul>
        </div>
    </section>
{% endblock %}

{% block extra_js %}
<script>
function runCode() {
    const code = document.getElementById('code-input').value;
    const output = document.getElementById('output');
    
    output.innerHTML = '<div class="output-success">Sistema de coordenadas executado! Veja como tuplas sÃ£o perfeitas para dados imutÃ¡veis.</div>';
}
</script>
{% endblock %}